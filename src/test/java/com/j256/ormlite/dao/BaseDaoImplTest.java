package com.j256.ormlite.dao;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNotSame;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.OneToOne;

import org.junit.Before;
import org.junit.Test;

import com.j256.ormlite.BaseOrmLiteTest;
import com.j256.ormlite.field.DataType;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.field.DatabaseFieldConfig;
import com.j256.ormlite.stmt.StatementBuilder;
import com.j256.ormlite.table.DatabaseTable;
import com.j256.ormlite.table.DatabaseTableConfig;

public class BaseDaoImplTest extends BaseOrmLiteTest {

	private final static String STUFF_FIELD_NAME = "stuff";
	private final static String DEFAULT_VALUE_STRING = "1314199";
	private final static int DEFAULT_VALUE = Integer.parseInt(DEFAULT_VALUE_STRING);
	private final static int ALL_TYPES_STRING_WIDTH = 4;
	private final static String FOO_TABLE_NAME = "footable";
	private final static String ENUM_TABLE_NAME = "enumtable";

	private final static String NULL_BOOLEAN_TABLE_NAME = "nullbooltable";
	private final static String NULL_INT_TABLE_NAME = "nullinttable";

	private final static String DEFAULT_BOOLEAN_VALUE = "true";
	private final static String DEFAULT_STRING_VALUE = "foo";
	// this can't have non-zero milliseconds
	private static DateFormat defaultDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSSSS");
	private final static String DEFAULT_DATE_VALUE = "2010-07-16 01:31:17.000000";
	private final static String DEFAULT_DATE_LONG_VALUE = "1282768620000";
	private final static String DEFAULT_DATE_STRING_FORMAT = "MM/dd/yyyy HH-mm-ss-SSSSSS";
	private static DateFormat defaultDateStringFormat = new SimpleDateFormat(DEFAULT_DATE_STRING_FORMAT);
	private final static String DEFAULT_DATE_STRING_VALUE = "07/16/2010 01-31-17-000000";
	private final static String DEFAULT_BYTE_VALUE = "1";
	private final static String DEFAULT_SHORT_VALUE = "2";
	private final static String DEFAULT_INT_VALUE = "3";
	private final static String DEFAULT_LONG_VALUE = "4";
	private final static String DEFAULT_FLOAT_VALUE = "5";
	private final static String DEFAULT_DOUBLE_VALUE = "6";
	private final static String DEFAULT_ENUM_VALUE = "FIRST";
	private final static String DEFAULT_ENUM_NUMBER_VALUE = "1";

	protected Dao<Foo, Integer> fooDao;

	@Before
	@Override
	public void before() throws Exception {
		super.before();
		fooDao = createDao(Foo.class, true);
		assertEquals(Foo.class, ((BaseDaoImpl<Foo, Integer>) fooDao).getDataClass());
	}

	@Test
	public void testCreateDaoStatic() throws Exception {
		Dao<Foo, Integer> fooDao = BaseDaoImpl.createDao(databaseType, connectionSource, Foo.class);
		String stuff = "stuff";
		Foo foo = new Foo();
		foo.stuff = stuff;
		assertEquals(1, fooDao.create(foo));

		// now we query for foo from the database to make sure it was persisted right
		Foo foo2 = fooDao.queryForId(foo.id);
		assertNotNull(foo2);
		assertEquals(foo.id, foo2.id);
		assertEquals(stuff, foo2.stuff);
	}

	@Test
	public void testCreateUpdateDelete() throws Exception {
		String s1 = "stuff";
		Foo foo1 = new Foo();
		foo1.stuff = s1;
		assertEquals(0, foo1.id);

		// persist foo to db through the dao and sends the id on foo because it was auto-generated by the db
		assertEquals(1, fooDao.create(foo1));
		assertTrue(foo1.id != 0);
		assertEquals(s1, foo1.stuff);

		// now we query for foo from the database to make sure it was persisted right
		Foo foo2 = fooDao.queryForId(foo1.id);
		assertNotNull(foo2);
		assertEquals(foo1.id, foo2.id);
		assertEquals(s1, foo2.stuff);

		String s2 = "stuff2";
		foo2.stuff = s2;

		// now we update 1 row in a the database after changing foo
		assertEquals(1, fooDao.update(foo2));

		// now we get it from the db again to make sure it was updated correctly
		Foo foo3 = fooDao.queryForId(foo1.id);
		assertEquals(s2, foo3.stuff);
		assertEquals(1, fooDao.delete(foo2));

		assertNull(fooDao.queryForId(foo1.id));
	}

	@Test
	@ExpectedBehavior(expected = SQLException.class)
	public void doubleCreate() throws Exception {
		Dao<DoubleCreate, Object> doubleDao = createDao(DoubleCreate.class, true);
		int id = 313413123;
		DoubleCreate foo = new DoubleCreate();
		foo.id = id;
		assertEquals(1, doubleDao.create(foo));
		doubleDao.create(foo);
	}

	@Test
	public void iterateRemove() throws Exception {
		List<Foo> acctList = fooDao.queryForAll();
		int initialSize = acctList.size();

		Foo foo1 = new Foo();
		foo1.stuff = "s1";
		Foo foo2 = new Foo();
		foo2.stuff = "s2";
		Foo foo3 = new Foo();
		foo3.stuff = "s3";
		fooDao.create(foo1);
		fooDao.create(foo2);
		fooDao.create(foo3);

		assertTrue(foo1.id != foo2.id);
		assertTrue(foo1.id != foo3.id);
		assertTrue(foo2.id != foo3.id);

		assertEquals(foo1, fooDao.queryForId(foo1.id));
		assertEquals(foo2, fooDao.queryForId(foo2.id));
		assertEquals(foo3, fooDao.queryForId(foo3.id));

		acctList = fooDao.queryForAll();
		assertEquals(initialSize + 3, acctList.size());
		assertEquals(foo1, acctList.get(acctList.size() - 3));
		assertEquals(foo2, acctList.get(acctList.size() - 2));
		assertEquals(foo3, acctList.get(acctList.size() - 1));
		int acctC = 0;
		Iterator<Foo> iterator = fooDao.iterator();
		while (iterator.hasNext()) {
			Foo foo = iterator.next();
			if (acctC == acctList.size() - 3) {
				assertEquals(foo1, foo);
			} else if (acctC == acctList.size() - 2) {
				iterator.remove();
				assertEquals(foo2, foo);
			} else if (acctC == acctList.size() - 1) {
				assertEquals(foo3, foo);
			}
			acctC++;
		}
		assertEquals(initialSize + 3, acctC);
	}

	@Test
	public void testGeneratedField() throws Exception {
		Foo foo1 = new Foo();
		foo1.stuff = "s1";
		assertEquals(0, foo1.id);
		assertEquals(1, fooDao.create(foo1));
		assertTrue(foo1.id != 0);
	}

	@Test
	public void testGeneratedIdNotNullField() throws Exception {
		Foo foo1 = new Foo();
		foo1.stuff = "s1";
		assertEquals(0, foo1.id);
		assertEquals(1, fooDao.create(foo1));
		assertTrue(foo1.id != 0);
	}

	@Test
	public void objectToString() throws Exception {
		String stuff = "foo123231";
		Foo foo1 = new Foo();
		foo1.stuff = stuff;
		String objStr = fooDao.objectToString(foo1);
		assertTrue(objStr.contains(Integer.toString(foo1.id)));
		assertTrue(objStr.contains(stuff));
	}

	@Test
	public void createNull() throws Exception {
		assertEquals(0, fooDao.create(null));
	}

	@Test
	public void updateNull() throws Exception {
		assertEquals(0, fooDao.update(null));
	}

	@Test
	public void updateIdNull() throws Exception {
		assertEquals(0, fooDao.updateId(null, null));
	}

	@Test
	public void deleteNull() throws Exception {
		assertEquals(0, fooDao.delete((Foo) null));
	}

	@Test(expected = IllegalStateException.class)
	public void closeInIterator() throws Exception {
		Foo foo1 = new Foo();
		foo1.stuff = "s1";
		fooDao.create(foo1);
		Iterator<Foo> iterator = fooDao.iterator();
		while (iterator.hasNext()) {
			iterator.next();
			closeConnection();
		}
	}

	@Test(expected = IllegalStateException.class)
	public void closeIteratorFirst() throws Exception {
		Foo foo1 = new Foo();
		foo1.stuff = "s1";
		fooDao.create(foo1);
		closeConnection();
		fooDao.iterator();
	}

	@Test(expected = IllegalStateException.class)
	public void closeIteratorBeforeNext() throws Exception {
		Foo foo1 = new Foo();
		foo1.stuff = "s1";
		fooDao.create(foo1);
		Iterator<Foo> iterator = fooDao.iterator();
		while (iterator.hasNext()) {
			closeConnection();
			iterator.next();
		}
	}

	@Test(expected = IllegalStateException.class)
	public void closeIteratorBeforeRemove() throws Exception {
		Foo foo1 = new Foo();
		foo1.stuff = "s1";
		fooDao.create(foo1);
		Iterator<Foo> iterator = fooDao.iterator();
		while (iterator.hasNext()) {
			iterator.next();
			closeConnection();
			iterator.remove();
		}
	}

	@Test(expected = IllegalStateException.class)
	public void noNextBeforeRemove() throws Exception {
		Foo foo1 = new Foo();
		foo1.stuff = "s1";
		fooDao.create(foo1);
		Iterator<Foo> iterator = fooDao.iterator();
		iterator.remove();
	}

	@Test
	public void testIteratePageSize() throws Exception {
		for (int i = 0; i < 1000; i++) {
			Foo foo = new Foo();
			foo.stuff = Integer.toString(i);
			assertEquals(1, fooDao.create(foo));
		}
		Iterator<Foo> iterator = fooDao.iterator();
		while (iterator.hasNext()) {
			iterator.next();
			iterator.remove();
		}
	}

	@Test
	public void testDeleteObjects() throws Exception {
		List<Foo> fooList = new ArrayList<Foo>();
		for (int i = 0; i < 100; i++) {
			Foo foo = new Foo();
			foo.stuff = Integer.toString(i);
			assertEquals(1, fooDao.create(foo));
			fooList.add(foo);
		}

		assertEquals(fooList.size(), fooDao.delete(fooList));
		assertEquals(0, fooDao.queryForAll().size());
	}

	@Test
	public void testDeleteObjectsNone() throws Exception {
		List<Foo> fooList = new ArrayList<Foo>();
		assertEquals(fooList.size(), fooDao.delete(fooList));
		assertEquals(0, fooDao.queryForAll().size());
	}

	@Test
	public void testDeleteIds() throws Exception {
		List<Integer> fooIdList = new ArrayList<Integer>();
		for (int i = 0; i < 100; i++) {
			Foo foo = new Foo();
			assertEquals(1, fooDao.create(foo));
			fooIdList.add(foo.id);
		}

		assertEquals(fooIdList.size(), fooDao.deleteIds(fooIdList));
		assertEquals(0, fooDao.queryForAll().size());
	}

	@Test
	public void testDeleteIdsNone() throws Exception {
		List<Integer> fooIdList = new ArrayList<Integer>();
		assertEquals(fooIdList.size(), fooDao.deleteIds(fooIdList));
		assertEquals(0, fooDao.queryForAll().size());
	}

	@Test
	public void hasNextAfterDone() throws Exception {
		Iterator<Foo> iterator = fooDao.iterator();
		while (iterator.hasNext()) {
		}
		assertFalse(iterator.hasNext());
	}

	@Test(expected = IllegalStateException.class)
	public void nextWithoutHasNext() throws Exception {
		Iterator<Foo> iterator = fooDao.iterator();
		iterator.next();
	}

	@Test(expected = IllegalStateException.class)
	public void removeAfterDone() throws Exception {
		Iterator<Foo> iterator = fooDao.iterator();
		assertFalse(iterator.hasNext());
		iterator.remove();
	}

	@Test
	public void iteratorNoResults() throws Exception {
		Iterator<Foo> iterator = fooDao.iterator();
		assertFalse(iterator.hasNext());
		assertNull(iterator.next());
	}

	@Test
	public void testCreateNoId() throws Exception {
		Dao<NoId, Object> whereDao = createDao(NoId.class, true);
		NoId noId = new NoId();
		assertEquals(0, whereDao.queryForAll().size());
		// this should work even though there is no id
		whereDao.create(noId);
		assertEquals(1, whereDao.queryForAll().size());
	}

	@Test
	public void testJustIdCreateQueryDelete() throws Exception {
		Dao<JustId, Object> justIdDao = createDao(JustId.class, true);
		String id = "just-id";
		JustId justId = new JustId();
		justId.id = id;
		assertEquals(1, justIdDao.create(justId));
		JustId justId2 = justIdDao.queryForId(id);
		assertNotNull(justId2);
		assertEquals(id, justId2.id);
		assertEquals(1, justIdDao.delete(justId));
		assertNull(justIdDao.queryForId(id));
		// update should fail during construction
	}

	@Test
	public void testJustIdUpdateId() throws Exception {
		Dao<JustId, Object> justIdDao = createDao(JustId.class, true);
		String id = "just-id-update-1";
		JustId justId = new JustId();
		justId.id = id;
		assertEquals(1, justIdDao.create(justId));
		JustId justId2 = justIdDao.queryForId(id);
		assertNotNull(justId2);
		assertEquals(id, justId2.id);
		String id2 = "just-id-update-2";
		// change the id
		assertEquals(1, justIdDao.updateId(justId2, id2));
		assertNull(justIdDao.queryForId(id));
		JustId justId3 = justIdDao.queryForId(id2);
		assertNotNull(justId3);
		assertEquals(id2, justId3.id);
		assertEquals(1, justIdDao.delete(justId3));
		assertNull(justIdDao.queryForId(id));
		assertNull(justIdDao.queryForId(id2));
	}

	@Test
	public void testJustIdRefresh() throws Exception {
		String stuff1 = "just-id-refresh-1";
		Foo foo1 = new Foo();
		foo1.stuff = stuff1;
		assertEquals(1, fooDao.create(foo1));
		int id = foo1.id;
		Foo foo2 = fooDao.queryForId(id);
		assertNotNull(foo2);
		assertEquals(id, foo2.id);
		assertEquals(stuff1, foo2.stuff);
		String stuff2 = "just-id-refresh-2";
		foo2.stuff = stuff2;

		// change the id in the db
		assertEquals(1, fooDao.update(foo2));
		Foo foo3 = fooDao.queryForId(id);
		assertNotNull(foo3);
		assertEquals(id, foo3.id);
		assertEquals(stuff2, foo3.stuff);

		assertEquals(stuff1, foo1.stuff);
		assertEquals(1, fooDao.refresh(foo1));
		assertEquals(stuff2, foo1.stuff);
	}

	@Test
	public void testSpringConstruction() throws Exception {
		BaseDaoImpl<Foo, Integer> fooDao = new BaseDaoImpl<Foo, Integer>(Foo.class) {
		};
		try {
			fooDao.create(new Foo());
			fail("Should have thrown a npe because of missing dataSource stuff");
		} catch (NullPointerException e) {
			// expected
		}
		fooDao.setConnectionSource(connectionSource);
		fooDao.setDatabaseType(databaseType);
		fooDao.initialize();
		Foo foo = new Foo();
		assertEquals(1, fooDao.create(foo));
		assertEquals(1, fooDao.delete(foo));
	}

	@Test
	public void testForeignCreation() throws Exception {
		Dao<ForeignWrapper, Integer> wrapperDao = createDao(ForeignWrapper.class, true);
		Dao<Foreign, Integer> foreignDao = createDao(Foreign.class, true);

		Foreign foreign = new Foreign();
		String stuff1 = "stuff1";
		foreign.stuff = stuff1;
		// this sets the foreign id
		assertEquals(1, foreignDao.create(foreign));

		ForeignWrapper wrapper = new ForeignWrapper();
		wrapper.foreign = foreign;
		// this sets the wrapper id
		assertEquals(1, wrapperDao.create(wrapper));

		ForeignWrapper wrapper2 = wrapperDao.queryForId(wrapper.id);
		assertEquals(wrapper.id, wrapper2.id);
		assertEquals(wrapper.foreign.id, wrapper2.foreign.id);
		assertTrue(wrapperDao.objectsEqual(wrapper, wrapper2));
		// this won't be true because wrapper2.foreign is a shell
		assertFalse(foreignDao.objectsEqual(foreign, wrapper2.foreign));
		assertNull(wrapper2.foreign.stuff);
		assertEquals(1, foreignDao.refresh(wrapper2.foreign));
		// now it should be true
		assertTrue(foreignDao.objectsEqual(foreign, wrapper2.foreign));
		assertEquals(stuff1, wrapper2.foreign.stuff);

		// create a new foreign
		foreign = new Foreign();
		String stuff2 = "stuff2";
		foreign.stuff = stuff2;
		// this sets the foreign id
		assertEquals(1, foreignDao.create(foreign));

		// change the foreign object
		wrapper.foreign = foreign;
		// update it
		assertEquals(1, wrapperDao.update(wrapper));

		wrapper2 = wrapperDao.queryForId(wrapper.id);
		assertEquals(wrapper.id, wrapper2.id);
		assertEquals(wrapper.foreign.id, wrapper2.foreign.id);
		assertTrue(wrapperDao.objectsEqual(wrapper, wrapper2));
		// this won't be true because wrapper2.foreign is a shell
		assertFalse(foreignDao.objectsEqual(foreign, wrapper2.foreign));
		assertNull(wrapper2.foreign.stuff);
		assertEquals(1, foreignDao.refresh(wrapper2.foreign));
		// now it should be true
		assertTrue(foreignDao.objectsEqual(foreign, wrapper2.foreign));
		assertEquals(stuff2, wrapper2.foreign.stuff);
	}

	@Test
	public void testForeignRefreshNoChange() throws Exception {
		Dao<ForeignWrapper, Integer> wrapperDao = createDao(ForeignWrapper.class, true);
		Dao<Foreign, Integer> foreignDao = createDao(Foreign.class, true);

		Foreign foreign = new Foreign();
		String stuff1 = "stuff1";
		foreign.stuff = stuff1;
		// this sets the foreign id
		assertEquals(1, foreignDao.create(foreign));

		ForeignWrapper wrapper = new ForeignWrapper();
		wrapper.foreign = foreign;
		// this sets the wrapper id
		assertEquals(1, wrapperDao.create(wrapper));

		ForeignWrapper wrapper2 = wrapperDao.queryForId(wrapper.id);
		assertEquals(1, foreignDao.refresh(wrapper2.foreign));
		Foreign foreign2 = wrapper2.foreign;
		assertEquals(stuff1, foreign2.stuff);

		assertEquals(1, wrapperDao.refresh(wrapper2));
		assertSame(foreign2, wrapper2.foreign);
		assertEquals(stuff1, wrapper2.foreign.stuff);

		// now, in the background, we change the foreign
		ForeignWrapper wrapper3 = wrapperDao.queryForId(wrapper.id);
		Foreign foreign3 = new Foreign();
		String stuff3 = "stuff3";
		foreign3.stuff = stuff3;
		assertEquals(1, foreignDao.create(foreign3));
		wrapper3.foreign = foreign3;
		assertEquals(1, wrapperDao.update(wrapper3));

		assertEquals(1, wrapperDao.refresh(wrapper2));
		// now all of a sudden wrapper2 should not have the same foreign field
		assertNotSame(foreign2, wrapper2.foreign);
		assertNull(wrapper2.foreign.stuff);
	}

	@Test
	public void testMultipleForeignWrapper() throws Exception {
		Dao<MultipleForeignWrapper, Integer> multipleWrapperDao = createDao(MultipleForeignWrapper.class, true);
		Dao<ForeignWrapper, Integer> wrapperDao = createDao(ForeignWrapper.class, true);
		Dao<Foreign, Integer> foreignDao = createDao(Foreign.class, true);

		Foreign foreign = new Foreign();
		String stuff1 = "stuff1";
		foreign.stuff = stuff1;
		// this sets the foreign id
		assertEquals(1, foreignDao.create(foreign));

		ForeignWrapper wrapper = new ForeignWrapper();
		wrapper.foreign = foreign;
		// this sets the wrapper id
		assertEquals(1, wrapperDao.create(wrapper));

		MultipleForeignWrapper multiWrapper = new MultipleForeignWrapper();
		multiWrapper.foreign = foreign;
		multiWrapper.foreignWrapper = wrapper;
		// this sets the wrapper id
		assertEquals(1, multipleWrapperDao.create(multiWrapper));

		MultipleForeignWrapper multiWrapper2 = multipleWrapperDao.queryForId(multiWrapper.id);
		assertEquals(foreign.id, multiWrapper2.foreign.id);
		assertNull(multiWrapper2.foreign.stuff);
		assertEquals(wrapper.id, multiWrapper2.foreignWrapper.id);
		assertNull(multiWrapper2.foreignWrapper.foreign);

		assertEquals(1, foreignDao.refresh(multiWrapper2.foreign));
		assertEquals(stuff1, multiWrapper2.foreign.stuff);
		assertNull(multiWrapper2.foreignWrapper.foreign);

		assertEquals(1, wrapperDao.refresh(multiWrapper2.foreignWrapper));
		assertEquals(foreign.id, multiWrapper2.foreignWrapper.foreign.id);
		assertNull(multiWrapper2.foreignWrapper.foreign.stuff);

		assertEquals(1, foreignDao.refresh(multiWrapper2.foreignWrapper.foreign));
		assertEquals(stuff1, multiWrapper2.foreignWrapper.foreign.stuff);
	}

	@Test
	public void testRefreshNull() throws Exception {
		// this should be a noop
		assertEquals(0, fooDao.refresh(null));
	}

	@Test
	public void testGetSet() throws Exception {
		Dao<GetSet, Integer> getSetDao = createDao(GetSet.class, true);
		GetSet getSet = new GetSet();
		String stuff = "ewfewfewfew343u42f";
		getSet.setStuff(stuff);
		assertEquals(1, getSetDao.create(getSet));
		GetSet getSet2 = getSetDao.queryForId(getSet.id);
		assertEquals(stuff, getSet2.stuff);
	}

	@Test
	public void testQueryForFirst() throws Exception {
		Dao<Foo, Integer> fooDao = createDao(Foo.class, true);

		String stuff = "ewf4334234u42f";

		StatementBuilder<Foo, Integer> qb = fooDao.statementBuilder();
		qb.where().eq(STUFF_FIELD_NAME, stuff);

		assertNull(fooDao.queryForFirst(qb.prepareStatement()));

		Foo foo1 = new Foo();
		foo1.stuff = stuff;
		assertEquals(1, fooDao.create(foo1));

		// should still get foo1
		Foo foo2 = fooDao.queryForFirst(qb.prepareStatement());
		assertEquals(foo1.id, foo2.id);
		assertEquals(stuff, foo2.stuff);

		// create another with same stuff
		Foo foo3 = new Foo();
		String stuff2 = "ewf43342wefwffwefwe34u42f";
		foo3.stuff = stuff2;
		assertEquals(1, fooDao.create(foo3));

		foo2 = fooDao.queryForFirst(qb.prepareStatement());
		assertEquals(foo1.id, foo2.id);
		assertEquals(stuff, foo2.stuff);
	}

	@Test
	public void testFieldConfig() throws Exception {
		List<DatabaseFieldConfig> fieldConfigs = new ArrayList<DatabaseFieldConfig>();
		fieldConfigs.add(new DatabaseFieldConfig("id", "id2", DataType.UNKNOWN, null, 0, false, false, true, null,
				false, null, false, null, false, null));
		fieldConfigs.add(new DatabaseFieldConfig("stuff", "stuffy", DataType.UNKNOWN, null, 0, false, false, false,
				null, false, null, false, null, false, null));
		DatabaseTableConfig<NoAnno> tableConfig = new DatabaseTableConfig<NoAnno>(NoAnno.class, "noanno", fieldConfigs);
		Dao<NoAnno, Integer> noAnnotaionDao = createDao(tableConfig, true);
		NoAnno noa = new NoAnno();
		String stuff = "qpoqwpjoqwp12";
		noa.stuff = stuff;
		assertEquals(1, noAnnotaionDao.create(noa));
		NoAnno noa2 = noAnnotaionDao.queryForId(noa.id);
		assertEquals(noa.id, noa2.id);
		assertEquals(stuff, noa2.stuff);
	}

	@Test
	public void testFieldConfigForeign() throws Exception {
		List<DatabaseFieldConfig> noAnnotationsFieldConfigs = new ArrayList<DatabaseFieldConfig>();
		noAnnotationsFieldConfigs.add(new DatabaseFieldConfig("id", "idthingie", DataType.UNKNOWN, null, 0, false,
				false, true, null, false, null, false, null, false, null));
		noAnnotationsFieldConfigs.add(new DatabaseFieldConfig("stuff", "stuffy", DataType.UNKNOWN, null, 0, false,
				false, false, null, false, null, false, null, false, null));
		DatabaseTableConfig<NoAnno> noAnnotationsTableConfig =
				new DatabaseTableConfig<NoAnno>(NoAnno.class, noAnnotationsFieldConfigs);
		Dao<NoAnno, Integer> noAnnotaionDao = createDao(noAnnotationsTableConfig, true);
		NoAnno noa = new NoAnno();
		String stuff = "qpoqwpjoqwp12";
		noa.stuff = stuff;
		assertEquals(1, noAnnotaionDao.create(noa));
		assertNotNull(noAnnotaionDao.queryForId(noa.id));

		List<DatabaseFieldConfig> noAnnotationsForiegnFieldConfigs = new ArrayList<DatabaseFieldConfig>();
		noAnnotationsForiegnFieldConfigs.add(new DatabaseFieldConfig("id", "anotherid", DataType.UNKNOWN, null, 0,
				false, false, true, null, false, null, false, null, false, null));
		noAnnotationsForiegnFieldConfigs.add(new DatabaseFieldConfig("foreign", "foreignThingie", DataType.UNKNOWN,
				null, 0, false, false, false, null, true, noAnnotationsTableConfig, false, null, false, null));
		DatabaseTableConfig<NoAnnoFor> noAnnotationsForiegnTableConfig =
				new DatabaseTableConfig<NoAnnoFor>(NoAnnoFor.class, noAnnotationsForiegnFieldConfigs);

		Dao<NoAnnoFor, Integer> noAnnotaionForeignDao = createDao(noAnnotationsForiegnTableConfig, true);
		NoAnnoFor noaf = new NoAnnoFor();
		noaf.foreign = noa;
		assertEquals(1, noAnnotaionForeignDao.create(noaf));

		NoAnnoFor noaf2 = noAnnotaionForeignDao.queryForId(noaf.id);
		assertNotNull(noaf2);
		assertEquals(noaf.id, noaf2.id);
		assertEquals(noa.id, noaf2.foreign.id);
		assertNull(noaf2.foreign.stuff);
		assertEquals(1, noAnnotaionDao.refresh(noaf2.foreign));
		assertEquals(stuff, noaf2.foreign.stuff);
	}

	@Test
	public void testGeneratedIdNotNull() throws Exception {
		// we saw an error with the not null before the generated id stuff under hsqldb
		Dao<GeneratedIdNotNull, Integer> dao = createDao(GeneratedIdNotNull.class, true);
		assertEquals(1, dao.create(new GeneratedIdNotNull()));
	}

	@Test
	public void testBasicStuff() throws Exception {
		Dao<Basic, String> fooDao = createDao(Basic.class, true);

		String string = "s1";
		Basic foo1 = new Basic();
		foo1.id = string;
		assertEquals(1, fooDao.create(foo1));

		Basic foo2 = fooDao.queryForId(string);
		assertTrue(fooDao.objectsEqual(foo1, foo2));

		List<Basic> fooList = fooDao.queryForAll();
		assertEquals(1, fooList.size());
		assertTrue(fooDao.objectsEqual(foo1, fooList.get(0)));
		int i = 0;
		for (Basic foo3 : fooDao) {
			assertTrue(fooDao.objectsEqual(foo1, foo3));
			i++;
		}
		assertEquals(1, i);

		assertEquals(1, fooDao.delete(foo2));
		assertNull(fooDao.queryForId(string));
		fooList = fooDao.queryForAll();
		assertEquals(0, fooList.size());
		i = 0;
		for (Basic foo3 : fooDao) {
			assertTrue(fooDao.objectsEqual(foo1, foo3));
			i++;
		}
		assertEquals(0, i);
	}

	@Test
	@ExpectedBehavior(expected = SQLException.class)
	public void testMultiplePrimaryKey() throws Exception {
		Dao<Basic, String> fooDao = createDao(Basic.class, true);
		Basic foo1 = new Basic();
		foo1.id = "dup";
		assertEquals(1, fooDao.create(foo1));
		fooDao.create(foo1);
	}

	@Test
	public void testDefaultValue() throws Exception {
		Dao<DefaultValue, Object> defValDao = createDao(DefaultValue.class, true);
		DefaultValue defVal1 = new DefaultValue();
		assertEquals(1, defValDao.create(defVal1));
		List<DefaultValue> defValList = defValDao.queryForAll();
		assertEquals(1, defValList.size());
		DefaultValue defVal2 = defValList.get(0);
		assertEquals(DEFAULT_VALUE, (int) defVal2.intField);
	}

	@Test
	@ExpectedBehavior(expected = SQLException.class)
	public void testNotNull() throws Exception {
		Dao<NotNull, Object> defValDao = createDao(NotNull.class, true);
		NotNull notNull = new NotNull();
		defValDao.create(notNull);
	}

	@Test
	public void testNotNullOkay() throws Exception {
		Dao<NotNull, Object> defValDao = createDao(NotNull.class, true);
		NotNull notNull = new NotNull();
		notNull.notNull = "not null";
		assertEquals(1, defValDao.create(notNull));
	}

	@Test
	public void testGeneratedId() throws Exception {
		Dao<GeneratedId, Object> genIdDao = createDao(GeneratedId.class, true);
		GeneratedId genId = new GeneratedId();
		assertEquals(0, genId.id);
		assertEquals(1, genIdDao.create(genId));
		long id = genId.id;
		assertEquals(1, id);
		GeneratedId genId2 = genIdDao.queryForId(id);
		assertNotNull(genId2);
		assertEquals(id, genId2.id);

		genId = new GeneratedId();
		assertEquals(0, genId.id);
		assertEquals(1, genIdDao.create(genId));
		id = genId.id;
		assertEquals(2, id);
		genId2 = genIdDao.queryForId(id);
		assertNotNull(genId2);
		assertEquals(id, genId2.id);
	}

	@Test
	public void testAllTypes() throws Exception {
		Dao<AllTypes, Object> allDao = createDao(AllTypes.class, true);
		AllTypes allTypes = new AllTypes();
		String stringVal = "some string";
		boolean boolVal = true;
		// we have to round this because the db may not be storing millis
		long millis = (System.currentTimeMillis() / 1000) * 1000;
		Date dateVal = new Date(millis);
		Date dateLongVal = new Date(millis);
		Date dateStringVal = new Date(millis);
		byte byteVal = 117;
		short shortVal = 15217;
		int intVal = 1023213;
		long longVal = 1231231231231L;
		float floatVal = 123.13F;
		double doubleVal = 1413312.1231233;
		OurEnum ourEnum = OurEnum.FIRST;
		allTypes.stringField = stringVal;
		allTypes.booleanField = boolVal;
		allTypes.dateField = dateVal;
		allTypes.dateLongField = dateLongVal;
		allTypes.dateStringField = dateStringVal;
		allTypes.byteField = byteVal;
		allTypes.shortField = shortVal;
		allTypes.intField = intVal;
		allTypes.longField = longVal;
		allTypes.floatField = floatVal;
		allTypes.doubleField = doubleVal;
		allTypes.ourEnum = ourEnum;
		String stuff = "ewpjowpjogrjpogrjp";
		SerialField obj = new SerialField();
		obj.stuff = stuff;
		allTypes.objectField = obj;
		assertEquals(1, allDao.create(allTypes));
		List<AllTypes> allTypesList = allDao.queryForAll();
		assertEquals(1, allTypesList.size());
		assertTrue(allDao.objectsEqual(allTypes, allTypesList.get(0)));
	}

	@Test
	public void testAllTypesDefault() throws Exception {
		Dao<AllTypes, Object> allDao = createDao(AllTypes.class, true);
		AllTypes allTypes = new AllTypes();
		assertEquals(1, allDao.create(allTypes));
		List<AllTypes> allTypesList = allDao.queryForAll();
		assertEquals(1, allTypesList.size());
		assertTrue(allDao.objectsEqual(allTypes, allTypesList.get(0)));
	}

	@Test
	public void testNumberTypes() throws Exception {
		Dao<NumberTypes, Object> numberDao = createDao(NumberTypes.class, true);

		NumberTypes numberMins = new NumberTypes();
		numberMins.byteField = Byte.MIN_VALUE;
		numberMins.shortField = Short.MIN_VALUE;
		numberMins.intField = Integer.MIN_VALUE;
		numberMins.longField = Long.MIN_VALUE;
		numberMins.floatField = -1.0e+37F;
		numberMins.doubleField = -1.0e+307;
		assertEquals(1, numberDao.create(numberMins));

		NumberTypes numberMins2 = new NumberTypes();
		numberMins2.byteField = Byte.MIN_VALUE;
		numberMins2.shortField = Short.MIN_VALUE;
		numberMins2.intField = Integer.MIN_VALUE;
		numberMins2.longField = Long.MIN_VALUE;
		numberMins2.floatField = 1.0e-37F;
		// derby couldn't take 1.0e-307 for some reason
		numberMins2.doubleField = 1.0e-306;
		assertEquals(1, numberDao.create(numberMins2));

		NumberTypes numberMaxs = new NumberTypes();
		numberMaxs.byteField = Byte.MAX_VALUE;
		numberMaxs.shortField = Short.MAX_VALUE;
		numberMaxs.intField = Integer.MAX_VALUE;
		numberMaxs.longField = Long.MAX_VALUE;
		numberMaxs.floatField = 1.0e+37F;
		numberMaxs.doubleField = 1.0e+307;
		assertEquals(1, numberDao.create(numberMaxs));

		List<NumberTypes> allTypesList = numberDao.queryForAll();
		assertEquals(3, allTypesList.size());
		assertTrue(numberDao.objectsEqual(numberMins, allTypesList.get(0)));
		assertTrue(numberDao.objectsEqual(numberMins2, allTypesList.get(1)));
		assertTrue(numberDao.objectsEqual(numberMaxs, allTypesList.get(2)));
	}

	@Test
	@ExpectedBehavior(expected = SQLException.class)
	public void testStringWidthTooLong() throws Exception {
		if (!databaseType.isVarcharFieldWidthSupported()) {
			throw new SQLException("Oh well.  This database does not support field widths");
		}
		Dao<StringWidth, Object> stringWidthDao = createDao(StringWidth.class, true);
		StringWidth stringWidth = new StringWidth();
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < ALL_TYPES_STRING_WIDTH + 1; i++) {
			sb.append("c");
		}
		String string = sb.toString();
		assertTrue(string.length() > ALL_TYPES_STRING_WIDTH);
		stringWidth.stringField = string;
		stringWidthDao.create(stringWidth);
	}

	@Test
	public void testStringWidthOkay() throws Exception {
		Dao<StringWidth, Object> stringWidthDao = createDao(StringWidth.class, true);
		StringWidth stringWidth = new StringWidth();
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < ALL_TYPES_STRING_WIDTH; i++) {
			sb.append("c");
		}
		String string = sb.toString();
		assertTrue(string.length() == ALL_TYPES_STRING_WIDTH);
		stringWidth.stringField = string;
		assertEquals(1, stringWidthDao.create(stringWidth));
		List<StringWidth> stringWidthList = stringWidthDao.queryForAll();
		assertEquals(1, stringWidthList.size());
		assertTrue(stringWidthDao.objectsEqual(stringWidth, stringWidthList.get(0)));
	}

	@Test
	public void testCreateReserverdTable() throws Exception {
		Dao<Where, String> whereDao = createDao(Where.class, true);
		String id = "from-string";
		Where where = new Where();
		where.id = id;
		assertEquals(1, whereDao.create(where));
		Where where2 = whereDao.queryForId(id);
		assertEquals(id, where2.id);
		assertEquals(1, whereDao.delete(where2));
		assertNull(whereDao.queryForId(id));
	}

	@Test
	public void testCreateReserverdFields() throws Exception {
		Dao<ReservedField, Object> reservedDao = createDao(ReservedField.class, true);
		String from = "from-string";
		ReservedField res = new ReservedField();
		res.from = from;
		assertEquals(1, reservedDao.create(res));
		int id = res.select;
		ReservedField res2 = reservedDao.queryForId(id);
		assertNotNull(res2);
		assertEquals(id, res2.select);
		String group = "group-string";
		for (ReservedField reserved : reservedDao) {
			assertEquals(from, reserved.from);
			reserved.group = group;
			reservedDao.update(reserved);
		}
		Iterator<ReservedField> reservedIterator = reservedDao.iterator();
		while (reservedIterator.hasNext()) {
			ReservedField reserved = reservedIterator.next();
			assertEquals(from, reserved.from);
			assertEquals(group, reserved.group);
			reservedIterator.remove();
		}
		assertEquals(0, reservedDao.queryForAll().size());
	}

	@Test
	public void testEscapeCharInField() throws Exception {
		StringBuilder sb = new StringBuilder();
		String word = "foo";
		databaseType.appendEscapedWord(sb, word);
		String escaped = sb.toString();
		int index = escaped.indexOf(word);
		String escapeString = escaped.substring(0, index);

		Dao<Basic, String> fooDao = createDao(Basic.class, true);
		Basic foo1 = new Basic();
		String id = word + escapeString + word;
		foo1.id = id;
		assertEquals(1, fooDao.create(foo1));
		Basic foo2 = fooDao.queryForId(id);
		assertNotNull(foo2);
		assertEquals(id, foo2.id);
	}

	@Test
	public void testJavaxPersistenceAnnotations() throws Exception {
		Dao<Javax, Integer> javaxDao = createDao(Javax.class, true);
		Javax foo = new Javax();
		String stuff = "dqdqwdqwd";
		foo.stuff = stuff;
		assertEquals(1, javaxDao.create(foo));
		assertTrue(foo.id != 0);
		Javax foo2 = javaxDao.queryForId(foo.id);
		assertNotNull(foo2);
		assertEquals(foo.id, foo2.id);
		assertEquals(stuff, foo2.stuff);
	}

	@Test(expected = IllegalArgumentException.class)
	public void testJavaxUnknownType() throws Exception {
		createDao(JavaxUnknownType.class, true);
	}

	@Test
	public void testJavaxSerializable() throws Exception {
		Dao<JavaxSerialization, Object> dao = createDao(JavaxSerialization.class, true);
		JavaxSerialization serial = new JavaxSerialization();
		serial.obj = new SerialField();
		String stuff = "wpfjewpfjewpf";
		serial.obj.stuff = stuff;
		assertEquals(1, dao.create(serial));

		JavaxSerialization serial2 = dao.queryForId(serial.id);
		assertEquals(serial.id, serial2.id);
		assertEquals(serial.obj.stuff, serial2.obj.stuff);
	}

	@Test
	public void testJavaxForeign() throws Exception {
		Dao<JavaxForeign, Integer> wrapperDao = createDao(JavaxForeign.class, true);

		Foreign foreign = new Foreign();
		int foreignId = 35345435;
		foreign.id = foreignId;

		JavaxForeign javax = new JavaxForeign();
		javax.foreign = foreign;
		// this sets the wrapper id
		assertEquals(1, wrapperDao.create(javax));

		JavaxForeign javax2 = wrapperDao.queryForId(javax.id);
		assertEquals(javax.id, javax2.id);
		assertEquals(javax.foreign.id, javax2.foreign.id);
	}

	@Test
	public void testJavaxForeignOneToOne() throws Exception {
		Dao<JavaxForeignOneToOne, Integer> wrapperDao = createDao(JavaxForeignOneToOne.class, true);

		Foreign foreign = new Foreign();
		int foreignId = 35345435;
		foreign.id = foreignId;

		JavaxForeignOneToOne javax = new JavaxForeignOneToOne();
		javax.foreign = foreign;
		// this sets the wrapper id
		assertEquals(1, wrapperDao.create(javax));

		JavaxForeignOneToOne javax2 = wrapperDao.queryForId(javax.id);
		assertEquals(javax.id, javax2.id);
		assertEquals(javax.foreign.id, javax2.foreign.id);
	}

	@Test
	public void testGeneratedIdCapital() throws Exception {
		createDao(GeneratedColumnCapital.class, true);
	}

	@Test
	public void testObject() throws Exception {
		Dao<ObjectHolder, Integer> objDao = createDao(ObjectHolder.class, true);

		ObjectHolder foo1 = new ObjectHolder();
		foo1.obj = new SerialField();
		String stuff = "123j21p3j312";
		foo1.obj.stuff = stuff;
		String strObj = "fjpwefefwpjoefwjpojopfew";
		foo1.strObj = strObj;
		assertEquals(1, objDao.create(foo1));

		ObjectHolder foo2 = objDao.queryForId(foo1.id);
		assertTrue(objDao.objectsEqual(foo1, foo2));
	}

	@Test(expected = IllegalArgumentException.class)
	public void testNotSerializable() throws Exception {
		createDao(NotSerializable.class, true);
	}

	@Test
	public void testStringEnum() throws Exception {
		Dao<LocalEnumString, Object> fooDao = createDao(LocalEnumString.class, true);
		OurEnum ourEnum = OurEnum.SECOND;
		LocalEnumString foo = new LocalEnumString();
		foo.ourEnum = ourEnum;
		assertEquals(1, fooDao.create(foo));

		List<LocalEnumString> fooList = fooDao.queryForAll();
		assertEquals(1, fooList.size());
		assertEquals(ourEnum, fooList.get(0).ourEnum);
	}

	@Test(expected = SQLException.class)
	public void testUnknownStringEnum() throws Exception {
		Dao<LocalEnumString, Object> fooDao = createDao(LocalEnumString.class, true);
		OurEnum ourEnum = OurEnum.SECOND;
		LocalEnumString foo = new LocalEnumString();
		foo.ourEnum = ourEnum;
		assertEquals(1, fooDao.create(foo));

		Dao<LocalEnumString2, Object> foo2Dao = createDao(LocalEnumString2.class, false);
		foo2Dao.queryForAll();
	}

	@Test
	public void testIntEnum() throws Exception {
		Dao<LocalEnumInt, Object> fooDao = createDao(LocalEnumInt.class, true);
		OurEnum ourEnum = OurEnum.SECOND;
		LocalEnumInt foo = new LocalEnumInt();
		foo.ourEnum = ourEnum;
		assertEquals(1, fooDao.create(foo));

		List<LocalEnumInt> fooList = fooDao.queryForAll();
		assertEquals(1, fooList.size());
		assertEquals(ourEnum, fooList.get(0).ourEnum);
	}

	@Test(expected = SQLException.class)
	public void testUnknownIntEnum() throws Exception {
		Dao<LocalEnumInt, Object> fooDao = createDao(LocalEnumInt.class, true);
		OurEnum ourEnum = OurEnum.SECOND;
		LocalEnumInt foo = new LocalEnumInt();
		foo.ourEnum = ourEnum;
		assertEquals(1, fooDao.create(foo));

		Dao<LocalEnumInt2, Object> foo2Dao = createDao(LocalEnumInt2.class, false);
		foo2Dao.queryForAll();
	}

	@Test
	public void testUnknownIntUnknownValEnum() throws Exception {
		Dao<LocalEnumInt, Object> fooDao = createDao(LocalEnumInt.class, true);
		OurEnum ourEnum = OurEnum.SECOND;
		LocalEnumInt foo = new LocalEnumInt();
		foo.ourEnum = ourEnum;
		assertEquals(1, fooDao.create(foo));

		Dao<LocalEnumInt3, Object> foo2Dao = createDao(LocalEnumInt3.class, false);
		List<LocalEnumInt3> fooList = foo2Dao.queryForAll();
		assertEquals(1, fooList.size());
		assertEquals(OurEnum2.FIRST, fooList.get(0).ourEnum);
	}

	@Test
	public void testNullHandling() throws Exception {
		Dao<AllObjectTypes, Object> allDao = createDao(AllObjectTypes.class, true);
		AllObjectTypes all = new AllObjectTypes();
		assertEquals(1, allDao.create(all));
		List<AllObjectTypes> allList = allDao.queryForAll();
		assertEquals(1, allList.size());
		assertTrue(allDao.objectsEqual(all, allList.get(0)));
	}

	@Test
	public void testObjectNotNullHandling() throws Exception {
		Dao<AllObjectTypes, Object> allDao = createDao(AllObjectTypes.class, true);
		AllObjectTypes all = new AllObjectTypes();
		all.stringField = "foo";
		all.booleanField = false;
		Date dateValue = new Date(1279649192000L);
		all.dateField = dateValue;
		all.byteField = 0;
		all.shortField = 0;
		all.intField = 0;
		all.longField = 0L;
		all.floatField = 0F;
		all.doubleField = 0D;
		all.objectField = new SerialField();
		all.ourEnum = OurEnum.FIRST;
		assertEquals(1, allDao.create(all));
		List<AllObjectTypes> allList = allDao.queryForAll();
		assertEquals(1, allList.size());
		assertTrue(allDao.objectsEqual(all, allList.get(0)));
	}

	@Test
	public void testDefaultValueHandling() throws Exception {
		Dao<AllTypesDefault, Object> allDao = createDao(AllTypesDefault.class, true);
		AllTypesDefault all = new AllTypesDefault();
		assertEquals(1, allDao.create(all));
		List<AllTypesDefault> allList = allDao.queryForAll();
		assertEquals(1, allList.size());
		all.stringField = DEFAULT_STRING_VALUE;
		all.dateField = defaultDateFormat.parse(DEFAULT_DATE_VALUE);
		all.dateLongField = new Date(Long.parseLong(DEFAULT_DATE_LONG_VALUE));
		all.dateStringField = defaultDateStringFormat.parse(DEFAULT_DATE_STRING_VALUE);
		all.booleanField = Boolean.parseBoolean(DEFAULT_BOOLEAN_VALUE);
		all.booleanObj = Boolean.parseBoolean(DEFAULT_BOOLEAN_VALUE);
		all.byteField = Byte.parseByte(DEFAULT_BYTE_VALUE);
		all.byteObj = Byte.parseByte(DEFAULT_BYTE_VALUE);
		all.shortField = Short.parseShort(DEFAULT_SHORT_VALUE);
		all.shortObj = Short.parseShort(DEFAULT_SHORT_VALUE);
		all.intField = Integer.parseInt(DEFAULT_INT_VALUE);
		all.intObj = Integer.parseInt(DEFAULT_INT_VALUE);
		all.longField = Long.parseLong(DEFAULT_LONG_VALUE);
		all.longObj = Long.parseLong(DEFAULT_LONG_VALUE);
		all.floatField = Float.parseFloat(DEFAULT_FLOAT_VALUE);
		all.floatObj = Float.parseFloat(DEFAULT_FLOAT_VALUE);
		all.doubleField = Double.parseDouble(DEFAULT_DOUBLE_VALUE);
		all.doubleObj = Double.parseDouble(DEFAULT_DOUBLE_VALUE);
		all.ourEnum = OurEnum.valueOf(DEFAULT_ENUM_VALUE);
		assertFalse(allDao.objectsEqual(all, allList.get(0)));
	}

	@Test
	public void testBooleanDefaultValueHandling() throws Exception {
		Dao<BooleanDefault, Object> allDao = createDao(BooleanDefault.class, true);
		BooleanDefault all = new BooleanDefault();
		assertEquals(1, allDao.create(all));
		List<BooleanDefault> allList = allDao.queryForAll();
		assertEquals(1, allList.size());
		all.booleanField = Boolean.parseBoolean(DEFAULT_BOOLEAN_VALUE);
		all.booleanObj = Boolean.parseBoolean(DEFAULT_BOOLEAN_VALUE);
		assertFalse(allDao.objectsEqual(all, allList.get(0)));
	}

	@Test(expected = SQLException.class)
	public void testNullUnPersistToBooleanPrimitive() throws Exception {
		Dao<NullBoolean1, Object> null1Dao = createDao(NullBoolean1.class, true);
		NullBoolean1 nullThing = new NullBoolean1();
		assertEquals(1, null1Dao.create(nullThing));
		Dao<NullBoolean2, Object> null2Dao = createDao(NullBoolean2.class, false);
		null2Dao.queryForAll();
	}

	@Test(expected = SQLException.class)
	public void testNullUnPersistToIntPrimitive() throws Exception {
		Dao<NullInt1, Object> null1Dao = createDao(NullInt1.class, true);
		NullInt1 nullThing = new NullInt1();
		assertEquals(1, null1Dao.create(nullThing));
		Dao<NullInt2, Object> null2Dao = createDao(NullInt2.class, false);
		null2Dao.queryForAll();
	}

	@Test
	public void testQueryRaw() throws Exception {
		Dao<Foo, Object> fooDao = createDao(Foo.class, true);
		Foo foo = new Foo();
		String stuff = "eprjpejrre";
		foo.stuff = stuff;

		RawResults results = fooDao.queryForAllRaw("select * from " + FOO_TABLE_NAME);
		assertFalse(results.iterator().hasNext());
		assertEquals(1, fooDao.create(foo));

		results = fooDao.queryForAllRaw("select * from " + FOO_TABLE_NAME);
		int colN = results.getNumberColumns();
		String[] colNames = results.getColumnNames();
		Field[] fields = Foo.class.getDeclaredFields();
		for (int colC = 0; colC < colNames.length; colC++) {
			assertTrue(fields[colC].getName().equalsIgnoreCase(colNames[colC]));
		}
		CloseableIterator<String[]> iterator = results.iterator();
		assertTrue(iterator.hasNext());
		String[] result = iterator.next();
		assertEquals(colN, result.length);
		assertEquals(Integer.toString(foo.id), result[0]);
		assertEquals(stuff, result[1]);
		assertFalse(iterator.hasNext());
	}

	@Test
	public void testQueryRawIterator() throws Exception {
		Dao<Foo, Object> fooDao = createDao(Foo.class, true);
		Foo foo = new Foo();
		String stuff = "eprjpejrre";
		foo.stuff = stuff;

		RawResults results = fooDao.iteratorRaw("select * from " + FOO_TABLE_NAME);
		CloseableIterator<String[]> iterator = results.iterator();
		try {
			assertFalse(iterator.hasNext());
		} finally {
			iterator.close();
		}
		assertEquals(1, fooDao.create(foo));

		results = fooDao.queryForAllRaw("select * from " + FOO_TABLE_NAME);
		int colN = results.getNumberColumns();
		String[] colNames = results.getColumnNames();
		Field[] fields = Foo.class.getDeclaredFields();
		for (int colC = 0; colC < colNames.length; colC++) {
			assertTrue(fields[colC].getName().equalsIgnoreCase(colNames[colC]));
		}
		iterator = results.iterator();
		try {
			assertTrue(iterator.hasNext());
			String[] result = iterator.next();
			assertEquals(colN, result.length);
			assertEquals(Integer.toString(foo.id), result[0]);
			assertEquals(stuff, result[1]);
			assertFalse(iterator.hasNext());
		} finally {
			iterator.close();
		}
	}

	@Test
	public void testNotNullDefault() throws Exception {
		Dao<NotNullDefalt, Object> dao = createDao(NotNullDefalt.class, true);
		NotNullDefalt notNullDefault = new NotNullDefalt();
		assertEquals(1, dao.create(notNullDefault));
	}

	@Test
	public void testStringDefault() throws Exception {
		Dao<StringDefalt, Object> dao = createDao(StringDefalt.class, true);
		StringDefalt foo = new StringDefalt();
		assertEquals(1, dao.create(foo));
	}

	@Test
	public void testDateUpdate() throws Exception {
		Dao<LocalDate, Object> dao = createDao(LocalDate.class, true);
		LocalDate localDate = new LocalDate();
		// note: this does not have milliseconds
		Date date = new Date(2131232000);
		localDate.date = date;
		assertEquals(1, dao.create(localDate));
		List<LocalDate> allDates = dao.queryForAll();
		assertEquals(1, allDates.size());
		assertEquals(date, allDates.get(0).date);

		// now we update it
		assertEquals(1, dao.update(localDate));
		allDates = dao.queryForAll();
		assertEquals(1, allDates.size());
		assertEquals(date, allDates.get(0).date);

		// now we set it to null
		localDate.date = null;
		// now we update it
		assertEquals(1, dao.update(localDate));
		allDates = dao.queryForAll();
		assertEquals(1, allDates.size());
		// we should get null back and not some auto generated field
		assertNull(allDates.get(0).date);
	}

	@Test(expected = IllegalStateException.class)
	public void testSpringBadWiring() throws Exception {
		BaseDaoImpl<String, String> daoSupport = new BaseDaoImpl<String, String>(String.class) {
		};
		daoSupport.initialize();
	}

	/* ==================================================================================== */

	@DatabaseTable(tableName = FOO_TABLE_NAME)
	protected static class Foo {
		@DatabaseField(generatedId = true)
		public int id;
		@DatabaseField(columnName = STUFF_FIELD_NAME)
		public String stuff;
		public Foo() {
		}
		@Override
		public boolean equals(Object other) {
			if (other == null || other.getClass() != getClass())
				return false;
			return id == ((Foo) other).id;
		}
		@Override
		public String toString() {
			return "Foo.id=" + id;
		}
	}

	protected static class DoubleCreate {
		@DatabaseField(id = true)
		int id;
	}

	protected static class NoId {
		@DatabaseField
		public String notId;
	}

	private static class JustId {
		@DatabaseField(id = true)
		public String id;
	}

	private static class Foreign {
		@DatabaseField(generatedId = true)
		int id;
		@DatabaseField
		String stuff;
	}

	private static class ForeignWrapper {
		@DatabaseField(generatedId = true)
		int id;
		@DatabaseField(foreign = true)
		Foreign foreign;
	}

	private static class MultipleForeignWrapper {
		@DatabaseField(generatedId = true)
		int id;
		@DatabaseField(foreign = true)
		Foreign foreign;
		@DatabaseField(foreign = true)
		ForeignWrapper foreignWrapper;
	}

	protected static class GetSet {
		@DatabaseField(generatedId = true, useGetSet = true)
		private int id;
		@DatabaseField(useGetSet = true)
		private String stuff;

		public int getId() {
			return id;
		}
		public void setId(int id) {
			this.id = id;
		}
		public String getStuff() {
			return stuff;
		}
		public void setStuff(String stuff) {
			this.stuff = stuff;
		}
	}

	protected static class NoAnno {
		public int id;
		public String stuff;
		public NoAnno() {
		}
	}

	protected static class NoAnnoFor {
		public int id;
		public NoAnno foreign;
		public NoAnnoFor() {
		}
	}

	protected static class GeneratedIdNotNull {
		@DatabaseField(generatedId = true, canBeNull = false)
		public int id;
		@DatabaseField
		public String stuff;
		public GeneratedIdNotNull() {
		}
	}

	protected static class Basic {
		@DatabaseField(id = true)
		String id;
	}

	private static class DefaultValue {
		@DatabaseField(defaultValue = DEFAULT_VALUE_STRING)
		Integer intField;
		DefaultValue() {
		}
	}

	protected static class NotNull {
		@DatabaseField(canBeNull = false)
		String notNull;
		NotNull() {
		}
	}

	protected static class GeneratedId {
		@DatabaseField(generatedId = true)
		public int id;
		@DatabaseField
		String other;
		public GeneratedId() {
		}
	}

	protected static class AllTypes {
		@DatabaseField
		String stringField;
		@DatabaseField
		boolean booleanField;
		@DatabaseField
		Date dateField;
		@DatabaseField(dataType = DataType.JAVA_DATE_LONG)
		Date dateLongField;
		@DatabaseField(dataType = DataType.JAVA_DATE_STRING, format = DEFAULT_DATE_STRING_FORMAT)
		Date dateStringField;
		@DatabaseField
		byte byteField;
		@DatabaseField
		short shortField;
		@DatabaseField
		int intField;
		@DatabaseField
		long longField;
		@DatabaseField
		float floatField;
		@DatabaseField
		double doubleField;
		@DatabaseField
		SerialField objectField;
		@DatabaseField
		OurEnum ourEnum;
		AllTypes() {
		}
	}

	protected static class AllTypesDefault {
		@DatabaseField(defaultValue = DEFAULT_STRING_VALUE)
		String stringField;
		@DatabaseField(defaultValue = DEFAULT_DATE_VALUE)
		Date dateField;
		@DatabaseField(dataType = DataType.JAVA_DATE_LONG, defaultValue = DEFAULT_DATE_LONG_VALUE)
		Date dateLongField;
		@DatabaseField(dataType = DataType.JAVA_DATE_STRING, defaultValue = DEFAULT_DATE_STRING_VALUE, format = DEFAULT_DATE_STRING_FORMAT)
		Date dateStringField;
		@DatabaseField(defaultValue = DEFAULT_BOOLEAN_VALUE)
		boolean booleanField;
		@DatabaseField(defaultValue = DEFAULT_BOOLEAN_VALUE)
		Boolean booleanObj;
		@DatabaseField(defaultValue = DEFAULT_BYTE_VALUE)
		byte byteField;
		@DatabaseField(defaultValue = DEFAULT_BYTE_VALUE)
		Byte byteObj;
		@DatabaseField(defaultValue = DEFAULT_SHORT_VALUE)
		short shortField;
		@DatabaseField(defaultValue = DEFAULT_SHORT_VALUE)
		Short shortObj;
		@DatabaseField(defaultValue = DEFAULT_INT_VALUE)
		int intField;
		@DatabaseField(defaultValue = DEFAULT_INT_VALUE)
		Integer intObj;
		@DatabaseField(defaultValue = DEFAULT_LONG_VALUE)
		long longField;
		@DatabaseField(defaultValue = DEFAULT_LONG_VALUE)
		Long longObj;
		@DatabaseField(defaultValue = DEFAULT_FLOAT_VALUE)
		float floatField;
		@DatabaseField(defaultValue = DEFAULT_FLOAT_VALUE)
		Float floatObj;
		@DatabaseField(defaultValue = DEFAULT_DOUBLE_VALUE)
		double doubleField;
		@DatabaseField(defaultValue = DEFAULT_DOUBLE_VALUE)
		Double doubleObj;
		@DatabaseField
		SerialField objectField;
		@DatabaseField(defaultValue = DEFAULT_ENUM_VALUE)
		OurEnum ourEnum;
		@DatabaseField(defaultValue = DEFAULT_ENUM_NUMBER_VALUE, dataType = DataType.ENUM_INTEGER)
		OurEnum ourEnumNumber;
		AllTypesDefault() {
		}
	}

	protected static class BooleanDefault {
		@DatabaseField(defaultValue = DEFAULT_BOOLEAN_VALUE)
		boolean booleanField;
		@DatabaseField(defaultValue = DEFAULT_BOOLEAN_VALUE)
		Boolean booleanObj;
		BooleanDefault() {
		}
	}

	protected static class AllObjectTypes {
		@DatabaseField
		String stringField;
		@DatabaseField
		Boolean booleanField;
		@DatabaseField
		Date dateField;
		@DatabaseField
		Byte byteField;
		@DatabaseField
		Short shortField;
		@DatabaseField
		Integer intField;
		@DatabaseField
		Long longField;
		@DatabaseField
		Float floatField;
		@DatabaseField
		Double doubleField;
		@DatabaseField
		SerialField objectField;
		@DatabaseField
		OurEnum ourEnum;
		AllObjectTypes() {
		}
	}

	protected static class NumberTypes {
		@DatabaseField
		public byte byteField;
		@DatabaseField
		public short shortField;
		@DatabaseField
		public int intField;
		@DatabaseField
		public long longField;
		@DatabaseField
		public float floatField;
		@DatabaseField
		public double doubleField;
		public NumberTypes() {
		}
	}

	protected static class StringWidth {
		@DatabaseField(width = ALL_TYPES_STRING_WIDTH)
		String stringField;
		StringWidth() {
		}
	}

	// for testing reserved table names as fields
	private static class Where {
		@DatabaseField(id = true)
		public String id;
	}

	// for testing reserved words as field names
	protected static class ReservedField {
		@DatabaseField(id = true)
		public int select;
		@DatabaseField
		public String from;
		@DatabaseField
		public String table;
		@DatabaseField
		public String where;
		@DatabaseField
		public String group;
		@DatabaseField
		public String order;
		@DatabaseField
		public String values;
		public ReservedField() {
		}
	}

	protected static class Javax {
		@Id
		@GeneratedValue
		public int id;
		@Column(name = STUFF_FIELD_NAME)
		public String stuff;
		public Javax() {
		}
	}

	protected static class JavaxUnknownType {
		@Id
		@GeneratedValue
		public int id;
		// this thing is not serializable
		@Column
		public Javax Javax;
		public JavaxUnknownType() {
		}
	}

	protected static class JavaxSerialization {
		@Id
		@GeneratedValue
		public int id;
		// this is serializable
		@Column
		public SerialField obj;
		public JavaxSerialization() {
		}
	}

	protected static class JavaxForeign {
		@Id
		@GeneratedValue
		public int id;
		@ManyToOne
		Foreign foreign;
		public JavaxForeign() {
		}
	}

	protected static class JavaxForeignOneToOne {
		@Id
		@GeneratedValue
		public int id;
		@OneToOne
		Foreign foreign;
		public JavaxForeignOneToOne() {
		}
	}

	// test the field name that has a capital letter in it
	protected static class GeneratedColumnCapital {
		@DatabaseField(generatedId = true, columnName = "idCap")
		public int id;
		@DatabaseField
		String other;
		public GeneratedColumnCapital() {
		}
	}

	protected static class ObjectHolder {
		@DatabaseField(generatedId = true)
		public int id;
		@DatabaseField
		public SerialField obj;
		@DatabaseField(dataType = DataType.SERIALIZABLE)
		public String strObj;
		public ObjectHolder() {
		}
	}

	protected static class NotSerializable {
		@DatabaseField(generatedId = true)
		public int id;
		@DatabaseField(dataType = DataType.SERIALIZABLE)
		public ObjectHolder obj;
		public NotSerializable() {
		}
	}

	protected static class SerialField implements Serializable {
		private static final long serialVersionUID = -3883857119616908868L;
		public String stuff;
		public SerialField() {
		}
		@Override
		public int hashCode() {
			return stuff.hashCode();
		}
		@Override
		public boolean equals(Object obj) {
			if (obj == null || obj.getClass() != getClass()) {
				return false;
			}
			SerialField other = (SerialField) obj;
			if (stuff == null) {
				return other.stuff == null;
			} else {
				return stuff.equals(other.stuff);
			}
		}
	}

	@DatabaseTable(tableName = ENUM_TABLE_NAME)
	protected static class LocalEnumString {
		@DatabaseField
		OurEnum ourEnum;
	}

	@DatabaseTable(tableName = ENUM_TABLE_NAME)
	protected static class LocalEnumString2 {
		@DatabaseField
		OurEnum2 ourEnum;
	}

	@DatabaseTable(tableName = ENUM_TABLE_NAME)
	protected static class LocalEnumInt {
		@DatabaseField(dataType = DataType.ENUM_INTEGER)
		OurEnum ourEnum;
	}

	@DatabaseTable(tableName = ENUM_TABLE_NAME)
	protected static class LocalEnumInt2 {
		@DatabaseField(dataType = DataType.ENUM_INTEGER)
		OurEnum2 ourEnum;
	}

	@DatabaseTable(tableName = ENUM_TABLE_NAME)
	protected static class LocalEnumInt3 {
		@DatabaseField(dataType = DataType.ENUM_INTEGER, unknownEnumName = "FIRST")
		OurEnum2 ourEnum;
	}

	private enum OurEnum {
		FIRST,
		SECOND, ;
	}

	private enum OurEnum2 {
		FIRST, ;
	}

	@DatabaseTable(tableName = NULL_BOOLEAN_TABLE_NAME)
	protected static class NullBoolean1 {
		@DatabaseField
		Boolean val;
	}

	@DatabaseTable(tableName = NULL_BOOLEAN_TABLE_NAME)
	protected static class NullBoolean2 {
		@DatabaseField(throwIfNull = true)
		boolean val;
	}

	@DatabaseTable(tableName = NULL_INT_TABLE_NAME)
	protected static class NullInt1 {
		@DatabaseField
		Integer val;
	}

	@DatabaseTable(tableName = NULL_INT_TABLE_NAME)
	protected static class NullInt2 {
		@DatabaseField(throwIfNull = true)
		int val;
	}

	@DatabaseTable
	protected static class NotNullDefalt {
		@DatabaseField(canBeNull = false, defaultValue = "3")
		String stuff;
	}

	@DatabaseTable
	protected static class StringDefalt {
		@DatabaseField(defaultValue = "3")
		String stuff;
	}

	@DatabaseTable
	protected static class LocalDate {
		@DatabaseField(generatedId = true)
		public int id;
		@DatabaseField
		Date date;
	}
}
