package com.j256.ormlite.misc;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.List;

import com.j256.ormlite.logger.Logger;
import com.j256.ormlite.logger.LoggerFactory;
import com.j256.ormlite.support.CompiledStatement;
import com.j256.ormlite.support.DatabaseConnection;

/**
 * A wrapped database connection returned by {@link WrappedConnectionSource}. This uses a proxy object so it can track
 * the statements.
 * 
 * @author graywatson
 */
public class WrappedDatabaseConnection implements InvocationHandler {

	private static final Logger logger = LoggerFactory.getLogger(WrappedDatabaseConnection.class);

	protected final DatabaseConnection databaseConnection;
	protected final Object underlyingConnection;
	protected final Object connectionProxy;
	private final List<WrappedStatement> wrappedStatements = new ArrayList<WrappedStatement>();

	public WrappedDatabaseConnection(DatabaseConnection connection, Class<?> connectionClass) {
		this.databaseConnection = connection;
		this.underlyingConnection = connection;
		this.connectionProxy =
				Proxy.newProxyInstance(getClass().getClassLoader(), new Class<?>[] { connectionClass }, this);
	}

	protected WrappedDatabaseConnection(DatabaseConnection databaseConnection, Object underlyingConnection,
			Class<?> connectionClass) {
		this.databaseConnection = databaseConnection;
		this.underlyingConnection = underlyingConnection;
		this.connectionProxy =
				Proxy.newProxyInstance(getClass().getClassLoader(), new Class<?>[] { connectionClass }, this);
	}

	public DatabaseConnection getDatabaseConnection() {
		return (DatabaseConnection) connectionProxy;
	}

	/**
	 * Get the object we are proxying.
	 */
	public Object getUnderlyingConnection() {
		return underlyingConnection;
	}

	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		logger.trace("{}: running method on connection: {}", this, method.getName());
		try {
			Object obj = method.invoke(getUnderlyingConnection(), args);
			if (method.getName().equals("compileStatement") && obj instanceof CompiledStatement) {
				WrappedStatement wrappedStatement = new WrappedStatement(obj, getStatementClass());
				wrappedStatements.add(wrappedStatement);
				logger.trace("{}: connection is wrapping CompiledStatement: {}", this, obj);
				obj = wrappedStatement.getPreparedStatement();
			}
			return obj;
		} catch (InvocationTargetException e) {
			// pass on the exception
			throw e.getTargetException();
		}
	}

	/**
	 * Return the class of the underlying statements generated by this connection.
	 */
	protected Class<?> getStatementClass() {
		return CompiledStatement.class;
	}

	/**
	 * See if all of the wrapped statements are ok.
	 */
	public boolean isOkay() {
		for (WrappedStatement wrappedStatement : wrappedStatements) {
			if (!wrappedStatement.isOkay()) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Close our connection.
	 */
	public void close() {
		wrappedStatements.clear();
	}
}
