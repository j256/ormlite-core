\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ormlite.info
@settitle ORMLite Documentation
@headings double
@c %**end of header

@c ----------------------------------------------------------------
@set ormlite_version 5.6
@set ormlite_year 2021
@set ormlite_date June @value{ormlite_year}
@set package ORMLite
@c ----------------------------------------------------------------

@titlepage
@headings off
@title ORMLite Package
@subtitle Version @value{ormlite_version}
@subtitle @value{ormlite_date}
@author Gray Watson

@page
This manual is licensed by Gray Watson under the Creative Commons Attribution-Share Alike 3.0 License.

Permission is granted to make and distribute verbatim copies of this manual provided the previous license
notice and this permission notice are preserved on all copies.
@end titlepage

@c ----------------------------------------------------------------

@c In the printed manual, we put the contents at the front.  For the digital manuals it is at the end. 
@iftex
@contents
@end iftex

@c ----------------------------------------------------------------

@node Top, Getting Started, (dir), (dir)
@top ORMLite
@everyheading @thischapter @| @thispage @| @today{}

Version @value{ormlite_version} -- @value{ormlite_date}

@cindex introduction
@cindex author
@cindex object relational mapping
@cindex hibernate
@cindex ibatis
ORMLite provides a lightweight @uref{http://en.wikipedia.org/wiki/Object-relational_mapping, Object Relational Mapping}
between Java classes and SQL databases.  There are certainly more mature ORMs which
provide this functionality including Hibernate and iBatis.  However, the author wanted a simple yet powerful
wrapper around the JDBC functions, and Hibernate and iBatis are significantly more complicated with many
dependencies.

@cindex databases supported
@cindex supported databases
ORMLite supports JDBC connections to MySQL, Postgres, H2, SQLite, Derby, HSQLDB, Microsoft SQL Server, and can be
extended to additional ones relatively easily.  ORMLite also supports native database calls on Android OS.  There
are also initial implementations for DB2, Oracle, generic ODBC, and Netezza although the author needs access to
an instance of each of these databases to tune the support.  Contact the author if your database is not supported.

To get started quickly with ORMLite, @pxref{Getting Started}.  Android users should also look at the Android specific
pages. @xref{Use With Android}.   You can also take a look at the  the examples section of the document which has
various working code packages and Android applications.  @xref{Examples}.
@ifhtml
There is also a @uref{http://ormlite.com/docs/ormlite.pdf, PDF version of this documentation}.
@end ifhtml
@iftex
There is also a @uref{http://ormlite.com/docs/ormlite.html, HTML version of this documentation}.
@end iftex

Gray Watson @uref{http://256stuff.com/gray/}

@menu
* Getting Started::             Getting started with ORMLite.
* Using::                       More details on how to use the system.
* Statement Builder::           How to use the custom statement builder.
* Use With Android::            Using with the Android OS.
* Advanced::                    Advanced concepts with ORMLite.
* How to Upgrade::              Upgrading from a previous version.
* Examples::                    Usage examples to help you get started.
* Contributions::               Contributions from others who helped.
* License::                     ISC Open Source license for the project.
* Index of Concepts::           Index of concepts in the manual.
@end menu

@c ----------------------------------------------------------------
@node Getting Started, Downloading, Top, Top
@chapter Getting Started

The following information should help you to get started with ORMLite.  Android users should also look at the Android
specific page after reading these pages here. @xref{Use With Android}.   

@cindex getting started
@cindex how to get started
@menu
* Downloading ::                Downloading the ORMLite jar.
* Starting Class::              Configuring a class to persist.
* Starting DAO::                Configuring a Data Access Object.
* Starting Code::               Code example on how its works.
@end menu

@c ----------------------------------------------------------------
@node Downloading, Starting Class, Getting Started, Getting Started
@section Downloading ORMLite Jar

@cindex how to download the jars
@cindex where to get new jars
To get started with ORMLite, you will need to download the jar files.  The @uref{http://ormlite.com/releases/, ORMLite release page}
is the default repository but the jars are also available from the @uref{http://repo1.maven.org/maven2/com/j256/ormlite/,
central maven repository} and from @uref{http://sourceforge.net/projects/ormlite/files/, Sourceforge}.

Users that are connecting to SQL databases via JDBC connections will need to download the @code{ormlite-jdbc-@value{ormlite_version}.jar}
and @code{ormlite-core-@value{ormlite_version}.jar} files.  For use with Android applications, you should download the
@code{ormlite-android-@value{ormlite_version}.jar} and @code{ormlite-core-@value{ormlite_version}.jar} files instead.  For either JDBC or
Android you will also need the ormlite-core release which has the ORMLite backend implementations.  ORMLite does not have
any required external dependencies although there are some @emph{optional} packages that you may want to use.  @xref{Dependencies}.  The
code works with Java 5 or later.

@c ----------------------------------------------------------------
@node Starting Class, Starting DAO, Downloading, Getting Started
@section Configuring a Class

@cindex configuring a class
@cindex class annotations
The following is an example class that is configured to be persisted to a database using ORMLite annotations.  The @code{@@DatabaseTable}
annotation configures the Account class to be persisted to the database table named @code{accounts}. The @code{@@DatabaseField} annotations map
the fields on the Account to the database columns with the same names.

The name field is configured as the primary key for the database table by using the @code{id = true} annotation field.  Also, notice that a
no-argument constructor is needed so the object can be returned by a query. For more information (JPA annotations and other ways to configure
classes) see the class setup information later in the manual.  @xref{Class Setup}.

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    
    @@DatabaseField(id = true)
    private String name;
    @@DatabaseField
    private String password;
    
    public Account() @{
        // ORMLite needs a no-arg constructor 
    @}
    public Account(String name, String password) @{
        this.name = name;
        this.password = password;
    @}
    public String getName() @{
        return name;
    @}
    public void setName(String name) @{
        this.name = name;
    @}
    public String getPassword() @{
        return password;
    @}
    public void setPassword(String password) @{
        this.password = password;
    @}
@}
@end example

@c ----------------------------------------------------------------
@node Starting DAO, Starting Code, Starting Class, Getting Started
@section Configuring a DAO

@cindex DAO
@cindex data access objects
@cindex createDao
@cindex DaoManager class
A typical Java pattern is to isolate the database operations in Data Access Objects (DAO) classes. Each DAO provides create, delete,
update, etc. type of functionality and specializes in the handling a single persisted class.  A simple way to build a DAO is
to use the @code{createDao} static method on the @code{DaoManager} class.  For example, to create a DAO for the Account class
defined above you would do:

@example
Dao<Account, String> accountDao =
  DaoManager.createDao(connectionSource, Account.class);
Dao<Order, Integer> orderDao =
  DaoManager.createDao(connectionSource, Order.class);
@end example

More information about setting up the DAOs is available later in the manual. @xref{DAO Setup}.

@c ----------------------------------------------------------------
@node Starting Code, Using, Starting DAO, Getting Started
@section Code Example

@cindex code example
@cindex starting code
This example uses the native Java H2 database to create an in-memory test database. You will need to download and add the H2 jar file to your
classpath if you want to run the example as-is.  See the @uref{http://www.h2database.com/html/download.html, H2 home page}.  @emph{NOTE:}
Android users should see the Android specific documentation later in the manual. @xref{Use With Android}.  There are also complete code
examples that can be used.  @xref{Examples}.

The code performs the following steps.

@itemize @bullet
@item It creates a connection source which handles connections to the database.
@item It instantiates a DAO for the Account object.
@item The @code{accounts} database table is created. This step is not needed if the table already exists.
@end itemize

@example
public class AccountApp @{

    public static void main(String[] args) throws Exception @{

        // this uses h2 by default but change to match your database
        String databaseUrl = "jdbc:h2:mem:account";
        // create a connection source to our database
        ConnectionSource connectionSource =
            new JdbcConnectionSource(databaseUrl);

        // instantiate the dao
        Dao<Account, String> accountDao =
            DaoManager.createDao(connectionSource, Account.class);

        // if you need to create the 'accounts' table make this call
        TableUtils.createTable(connectionSource, Account.class);
@end example

Once we have configured our database objects, we can use them to persist an Account to the database and query for it from
the database by its ID:

@example
        // create an instance of Account
        Account account = new Account();
        account.setName("Jim Coakley");

        // persist the account object to the database
        accountDao.create(account);

        // retrieve the account from the database by its id field (name)
        Account account2 = accountDao.queryForId("Jim Coakley");
        System.out.println("Account: " + account2.getName());

        // close the connection source
        connectionSource.close();
    @}
@}
@end example

You should be able to get started using ORMLite by this point. To understand more of the functionality available with ORMLite,
continue on with the next section.  @xref{Using}.

For more examples including working code and Android application projects @pxref{Examples}.

@c ----------------------------------------------------------------
@node Using, Class Setup, Starting Code, Top
@chapter How to Use

@cindex how to use
This chapter goes into more detail about how to use the various features in ORMLite.

@menu
* Class Setup::                 How to setup your classes to be persisted.
* Persisted Types::             Data types that can be persisted.
* Connection Source::           Setting up connections to databases.
* DAO Setup::                   How to configure the Data Access Objects.
* Database Notes::              Support databases and associated notes.
* Complete Wiring::             Tying all of the wiring together.
* Table Creation::              Creating tables and loading schema.
* Identity Columns::            How identity fields and columns work.
* DAO Usage::                   Using the Data Access Objects.
* Creating Indexes::            How to create indexes on fields.
* Raw Statements::              Issuing raw database statements.
* Foreign Objects::             Fields that represent foreign objects.
* Foreign Collection::          Fields that are collections of foreign objects.
* DAO Enabled Objects::         Another pattern for your data classes.
@end menu

@c ----------------------------------------------------------------
@node Class Setup, Local Annotations, Using, Using
@section Setting Up Your Classes

@cindex setting up your classes
@cindex class setup
To setup your classes to be persisted you need to do the following things:

@enumerate
@item Add the @@DatabaseTable annotation to the top of each class.  You can also use @@Entity.
@item Add the @@DatabaseField annotation right before each field to be persisted.  You can also use @@Column and others.
@item Add a no-argument constructor to each class with at least package visibility.
@end enumerate

@menu
* Local Annotations::                Adding the annotations to your classes.
* Javax Persistence Annotations::    Using javax.persistence annotations instead.
* No Arg Constructor::               A no-argument-constructor is also required.
@end menu

@c ----------------------------------------------------------------
@node Local Annotations, Javax Persistence Annotations, Class Setup, Class Setup
@subsection Adding ORMLite Annotations

@cindex annotations
@cindex java annotations
@cindex @@DatabaseTable
@cindex DatabaseTable annotation
Annotations are special code markers have have been available in Java since version 5 that provide meta information
about classes, methods, or fields.  To specify what classes and fields to store in the database, ORMLite
supports either its own annotations (@code{@@DatabaseTable} and @code{@@DatabaseField}) or the more standard
annotations from the @code{javax.persistence} package.  @xref{Javax Persistence Annotations}.   Annotations are the
easiest way to configure your classes but you can also configure the class using Java code or Spring XML.
@xref{Class Configuration}.

With ORMLite annotations, for each of the Java classes that you would like to persist to your SQL database, you
will need to add the @code{@@DatabaseTable} annotation right above the @code{public class} line.  Each class marked with
one of these annotations will be persisted into its own database table.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@DatabaseTable} annotations can have an optional @code{tableName} argument which specifies the name of the table
that corresponds to the class.   If not specified, the class name, with normalized case, is used by default.  With the above example
each @code{Account} object will be persisted as a row in the @code{accounts} table in the database.  If the @code{tableName}
was not specified, the @code{account} table would be used instead.

More advanced users may want to add a @code{daoClass} argument which specifies the class of the DAO object that will be
operating on the class.  This is used by the DaoManager to instantiate the DAO internally.  @xref{DaoManager}.

@cindex @@DatabaseField
@cindex DatabaseField annotation
Additionally, for each of the classes, you will need to add a @code{@@DatabaseField} annotation to each of the @emph{fields}
in the class that are to be persisted to the database.  Each field is persisted as a column of a database row.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{

    @@DatabaseField(id = true)
    private String name;

    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}
@end example

In the above example, each row in the @code{accounts} table has 2 columns:

@itemize @bullet
@item the @code{name} column which is a string and also is the database identity (id) of the row
@item the @code{password} column, also a string which can not be null
@end itemize 

The @@DatabaseField annotation can have the following fields:

@table @code

@cindex column name
@cindex name of database column
@anchor{columnName}
@item columnName

String name of the column in the database that will hold this field. If not set then the field name, with normalized case,
is used instead.

@cindex field type
@cindex jdbc type
@cindex SQL type
@cindex data type
@anchor{DatabaseField dataType}
@item dataType

The type of the field as the DataType class.  Usually the type is taken from Java class of the field and does not need
to be specified.  This corresponds to the SQL type.  @xref{Persisted Types}.

@cindex default value
@item defaultValue

String default value of the field when we are creating a new row in the table.  Default is none.

@cindex field width
@cindex width of field
@cindex length of field
@item width

Integer width of the field -- mostly used for string fields.  Default is 0 which means to take the data-type and database-specific
default.  For strings that means 255 characters although some databases do not support this.

@cindex can be null
@cindex null value allowed
@item canBeNull

Boolean whether the field can be assigned to null value. Default is true.  If set to false then you must provide a value
for this field on every object inserted into the database.

@cindex id field
@cindex key field
@cindex primary key field
@item id

Boolean whether the field is the id field or not. Default is false. Only one field can have this set in a class. Id fields
uniquely identity a row and are required if you want to use the query, update, refresh, and delete by ID methods. Only one
of this, @code{generatedId}, and @code{generatedIdSequence} can be specified.  @xref{Id Column}.

@cindex generated id
@cindex auto-generated id
@item generatedId

Boolean whether the field is an auto-generated id field. Default is false.  Only one field can have this set in a class.
This tells the database to auto-generate a corresponding id for every row inserted.  When an object with a generated-id
is created using the @code{Dao.create()} method, the database will generate an id for the row which will be returned and
set in the object by the create method.  Some databases require sequences for generated ids in which case the sequence
name will be auto-generated. To specify the name of the sequence use @code{generatedIdSequence}. Only one of this,
@code{id}, and @code{generatedIdSequence} can be specified.  @xref{GeneratedId Column}.

@cindex generated id sequence
@cindex database sequences
@cindex sequences
@item generatedIdSequence

String name of the sequence number to be used to generate this value.  Same as @code{generatedId} but you can specify the
sequence name to use.  Default is none. Only one field can have this set in a class. This is only necessary for databases
which require sequences for generated ids.  If you use generatedId instead then the code will auto-generate a sequence name.
Only one of this, @code{id}, and @code{generatedId} can be specified.  @xref{GeneratedIdSequence Column}.

@cindex foreign objects
@cindex remote objects
@item foreign

@cindex refreshing foreign objects
Boolean setting which identifies this field as corresponding to another class that is also stored in the database.
Default is false.  The field must not be a primitive type.  The other class must have an id field (either @code{id},
@code{generatedId}, or @code{generatedIdSequence}) which will be stored in this table. When an object is returned
from a query call, any foreign objects will @emph{just} have the id field set.  @xref{Foreign Objects}.

@cindex useGetSet
@cindex get and set method usage
@cindex using get and set methods
@cindex field access using getters and setters 
@item useGetSet

Boolean that says that the field should be accessed with get and set methods.  Default is false which instead uses
direct field access via Java reflection.  This may be necessary if the object you are storing has
protections around it.

@emph{NOTE:} The name of the get method @emph{must} match getXxx() where Xxx is the name of the field with the first
letter capitalized. The get @emph{must} return a class which matches the field's exactly. The set method @emph{must}
match setXxx(), have a single argument whose class matches the field's exactly, and return void.  For example:

@example
@@DatabaseField(useGetSet = true)
private Integer orderCount;

public Integer getOrderCount() @{
  return orderCount;
@}

public void setOrderCount(Integer orderCount) @{
  this.orderCount = orderCount;
@}
@end example

@cindex unknownEnumName
@cindex enumerated name unknown
@anchor{unknownEnumName}
@item unknownEnumName

If the field is a Java enumerated type then you can specify the name of a enumerated value which will be used if the
value of a database row is not found in the enumerated type.  If this is not specified and a database row @emph{does}
contain an unknown name or ordinal value then a @code{SQLException} is thrown when the row is being read from the database.
This is useful to handle backwards compatibility when handling out-of-date database values as well as forwards
compatibility if old software is accessing up-to-date data or if you have to roll a release back.

@cindex throwIfNull
@cindex primitive null values
@cindex null values and primitives
@item throwIfNull

Boolean that tells ORMLite to throw an exception if it sees a null value in a database row and is trying to store
it in a primitive field.  By default it is false.  If it is false and the database field is null, then the value of the
primitive will be set to 0 (false, null, etc.).  This can only be used on a primitive field.

@cindex persisted field
@item persisted

Set this to be false (default true) to not store this field in the database. This is useful if you want to have
the annotation on all of your fields but turn off the writing of some of them to the database.

@cindex parse format
@cindex format, field
@item format

This allows you to specify format information of a particular field.  Right now this is only applicable for a couple
of types including:

@itemize @bullet
@item @code{DATE_STRING} for specifying the format of the date string stored in the database  
@item @code{STRING_BYTES} for specifying the @code{Charset} used to encode the string as an array of bytes
@item @code{BOOLEAN_CHAR} for specifying characters representing the true and false values in the database. 
@end itemize 

@cindex unique constraint
@cindex constraint, unique
@anchor{unique constraints}
@item unique

Adds a constraint to the table so that this field that it has to be unique across all rows in the table.  For example, you
might have an Account class which has a generated account-id but you also want the email address to be unique across all
Accounts.  If more than one field is marked as unique in a table, then each of the fields by themselves must be unique.
For example, if you have the @code{firstName} and @code{lastName} fields, both with @code{unique=true} and you have "Bob",
"Smith" in the database, you cannot insert "Bob", "Jones" nor "Kevin", "Smith".

To have more than 1 field that are each unique in @emph{combination}, see the @code{uniqueCombo} setting.    You can also
use the @code{uniqueIndexName} to create an index for this field.  

@cindex multiple fields unique
@cindex unique, multiple fields
@cindex uniqueCombo
@item uniqueCombo

Adds a constraint to the table so that a combination of all fields that have @code{uniqueCombo} set to true has to be unique
across all rows in the table.  For example, if you have the @code{firstName} and @code{lastName} fields, both with
@code{uniqueCombo=true}, and you have "Bob", "Smith" in the database, you cannot insert another "Bob", "Smith" but you
@emph{can} insert "Bob", "Jones" and "Kevin", "Smith".

To have fields be unique by themselves, see the @code{unique} setting.  You can also use the @code{uniqueIndexName} to
create an index for this field.  

@cindex index creation
@cindex creating an index
@cindex field indexes
@anchor{index}
@item index

Boolean value (default false) to have the database add an index for this field. This will create an index with the name
columnName with a "_idx" suffix. To specify a specific name of the index or to index multiple fields, use the
@code{indexName} field.

@cindex unique index creation
@item uniqueIndex

Boolean value (default false) to have the database add a unique index for this field. Same as index but this will ensure that all of
the values in the index are unique.  If you just want to make sure of unique-ness then you can use the @code{unique} field instead.

@cindex index name
@cindex naming an index
@item indexName

String value (default none) to have the database add an index for this field with this name. You do not need to specify the index
boolean as well. To index multiple fields together in one index, each of the fields should have the same indexName value.

@cindex unique index name
@cindex naming a unique index
@item uniqueIndexName

String value (default none) to have the database add a unique index for this field with this name. Same as index but this will ensure
that all of the values in the index are unique.  For example, this means that you can insert @code{("pittsburgh", "pa")} and
@code{("harrisburg", "pa")} and @code{("pittsburgh", "tx")} but not another @code{("pittsburgh", "pa")}.

@cindex foreign object, auto refresh
@cindex auto refresh foreign objects
@cindex foreign auto refresh
@anchor{foreignAutoRefresh}
@item foreignAutoRefresh

Set this to be true (default false) to have a foreign field automagically refreshed when an object is queried.  The default is to just
have the ID field in the object retrieved and for the caller to call refresh on the correct DAO.  If this is set to true then, when the
object is queried, a separate database call will be made to load of the fields of the foreign object via an internal DAO.  @emph{NOTE:}
this will @emph{not} automagically create the foreign object if you create an object that has this field set. 

@emph{NOTE:} This will create another DAO object internally so low memory devices may want to call refresh by hand.

@emph{NOTE:} To protect against recursion, there are a couple of places were auto-refreshing has been limited.  If you are
auto-refreshing a class that itself has field with @code{foreignAutoRefresh} set to true or if you are auto-refreshing a class with
a foreign collection, in both cases the resulting field will be set to null and @emph{not} auto-refreshed.  You can always call
refresh on the field directly if you need it.

@emph{NOTE:} If you have an auto-refreshed field that is an object that also has an auto-refreshed field, you may want to tune the
@code{maxForeignAutoRefreshLevel} value.  See below.

@cindex max foreign auto-refresh level
@cindex limiting foreign auto-refresh levels
@item maxForeignAutoRefreshLevel

This can be used to set the maximum number of levels to configure foreign objects.  For example, if you have a @code{Question} which
has an foreign field of the best @code{Answer}, and the @code{Answer} has an foreign field to the corresponding question, then the
configuration back and forth can get large.  This is especially a problem with auto-refreshed fields when you lookup the @code{Question}
it could cause an infinite loop.  By default, ORMLite only goes through 2 levels but you can decrease it to 1 (0 is not valid) or increase
it.  The higher the number the more database transactions happen when you load in your @code{Question}.

In our example, the foreign fields in @code{Question} and @code{Answer} could be set to auto-refresh.  If this is true then with the
@code{maxForeignAutoRefreshLevel} set to 1, when you query for a @code{Question}, the @code{Answer} field will be auto-refreshed, but the
@code{Question} field on the answer will @emph{only} have its id field set.  It will not be auto-refreshed.

@cindex optional generated-id
@cindex generated-id optional
@anchor{allowGeneratedIdInsert}
@item allowGeneratedIdInsert

If this is set to true (default is false) then inserting an object with the ID field already set will not override it with a generated-id.
This is useful when you have a table where you are inserting items that sometimes have IDs and sometimes need them generated. This only works
if the database supports this behavior and if @code{generatedId} is also true for the field.

@cindex column definition, custom
@cindex custom column definition
@item columnDefinition

If this is set with a string then it will be used to define the column in the @code{CREATE TABLE} statement.  By default the database type is
used to auto-generate the SQL necessary to create the column.  The column name is provided by ORMLite.  For example:

@example
@@DatabaseField(columnDefinition = "LONGBLOB not null",
  dataType = DataType.BYTE_ARRAY)
public byte[] bigBunchOfBytes;
@end example

If you need to specify the full schema definition including the name, see @code{fullColumnDefinition} below.

@anchor{foreignAutoCreate}
@cindex foreignAutoCreate
@cindex foreign object, auto create
@cindex auto create foreign objects
@item foreignAutoCreate

Set this to be true (default false) to have the foreign field automatically created using an internal DAO if its ID field is not set (null or 0).
So when you call @code{dao.create()} on the parent object, any foreign field that has this set to true will possibly generate an additional
create call via an internal DAO.  By default you have to create the object using its DAO directly.  By default you have to create the object
using its DAO directly. This only works if @code{generatedId} is also set to true.

@example
// the account field in Order has foreignAutoCreate=true
Order order1 = new Order();
// account1 has not been created in the db yet, id field is null
order1.account = account1;
// this will create order1 in the order table _and_
// pass order1.account to the internal accountDao.create().
orderDao.create(order1);
@end example

@cindex version field
@cindex row versioning
@anchor{version field}
@item version

Set this to true (default false) to have this field be a version for the row.  A version field adds restrictions when an
object is updated to the datbase that protects against data corruption when multiple entities are updating the row at the
same time.  This is very useful in distributed database scenarios if (for example) a utility process is updating an
@code{Account} and you don't want to protect against overwriting a user update from the web-server.

@enumerate
@item The current-value of the version field is read from the object 
@item The update statement is augmented with a @code{"WHERE version = current-value"}
@item The new-value being updated in the database is changed by ORMLite to be the current-value + 1 or the current
@code{java.util.Date}
@item If the row has been updated by another entity then the update will not change the database since the current-value
will not match the version column in the database and 0 rows changed will be returned by the @code{update} method
@item However, if the current-value @emph{does} match the version field in the database then the row will be updated,
the object's version field will be set by ORMLite to the new-value, 1 will be returned from @code{update}
@end enumerate

Only the following field types are appropriate for version fields: @code{short}, @code{integer}, @code{long}, and @code{Date}
fields.  @code{Date} can also be stored as a string (@code{dataType = DataType.DATE_STRING}) or long
(@code{dataType = DataType.DATE_LONG}).

@cindex last modified field
@cindex modified last field
@cindex time row last modified
@cindex date row last modified
@emph{NOTE:} If you define a @code{Date} field to be a version then you can also use it as a modification time on the row.
When the object is created in the database, the version field will be automatically inserted with the current @code{Date}.
When the object is updated, the version field will be updated with the current @code{Date}.  Something like the following
works well (the @code{dataType=...} is optional):

@example
@@DatabaseField(version = true, dataType = DataType.DATE_LONG)
private Date lastModified;
@end example  

@cindex foreign column name
@item foreignColumnName

Name of the foreign object's field that is tied to this table. This does not need to be specified if you are using the
ID of the foreign object which is recommended. For example, if you have an @code{Order} object with a foreign
@code{Account} then you may want to key off of the @code{Account} name instead of the ID.

@emph{NOTE:} Setting this implies @code{foreignAutoRefresh} is also set to true because there is no way to refresh the
object since the id field is not stored in the database. So when this is set, the field will be automatically refreshed
in another database query.

@cindex read only fields
@cindex don't insert field
@cindex field not inserted
@cindex field read only
@cindex ignored by insert
@cindex auto-generated field
@cindex create date field
@cindex modification date field
@item readOnly

Set this to be true (default false) if this field is a read-only field. This field will be returned by queries
however it will be ignored during insert/create statements.  This can be used to represent create or modification
dates with the values being generated by the database.  You should specify the specific schema to create those dates
via the @code{columnDefinition} setting.

@cindex column definition, full
@cindex custom column definition
@cindex full column definition
@cindex fullColumnDefinition
@item foreignColumnName

Specify the SQL necessary to create this field in the database including the column name, which should be
properly escaped and in proper case depending on your database type. This can be used if you need to fully
describe the schema to enable some per-database feature or to override the default SQL generated. If you just need
to specify the schema for a column then the @code{columnDefinition} should be used instead.

@end table

@c ----------------------------------------------------------------
@node Javax Persistence Annotations, No Arg Constructor, Local Annotations, Class Setup
@subsection Using javax.persistence Annotations

@cindex JPA
@cindex javax.persistence
Instead of using the ORMLite annotations (@pxref{Local Annotations}), you can use the more standard
JPA annotations from the @code{javax.persistence} package.  In place of the @code{@@DatabaseTable} annotation, you can
use the @code{javax.persistence} @code{@@Entity} annotation.  For example:

@example
@@Entity(name = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@Entity} annotations can have an optional @code{name} argument which specifies the table name.   If not
specified, the class name with normalized case is used by default.

Instead of using the @code{@@DatabaseField} annotation on each of the fields, you can use the @code{javax.persistence}
annotations: @code{@@Column}, @code{@@Id}, @code{@@GeneratedValue}, @code{@@OneToOne}, @code{@@ManyToOne}, 
@code{@@JoinColumn}, and @code{@@Version}. For example:

@example
@@Entity(name = "accounts")
public class Account @{

    @@Id
    private String name;

    @@Column(nullable = false)
    private String password;
    @dots{}
@end example

The following @code{javax.persistence} annotations and fields are supported:

@table @code

@cindex @@Entity
@cindex Entity annotation
@item @@Entity

Specifies that the class is stored in the database. 

@table @code

@item name

Used to specify the name of the associated database table.  If not provided then the class name is used.

@end table

@cindex @@Column
@cindex Column annotation
@item @@Column

Specifies the field to be persisted to the database.  You can also just specify the @code{@@Id} annotation.  The
following annotation fields are supported, the rest are ignored.

@table @code

@item name

Used to specify the name of the associated database column.  If not provided then the field name is taken.

@cindex field width
@cindex width of field
@cindex length of field
@item length

Specifies the length (or width) of the database field.  Maybe only applicable for Strings and only supported by
certain database types.  Default for those that do is 255.   Same as the @code{width} field in the
@code{@@DatabaseField} annotation.

@cindex can be null
@cindex null value allowed
@item nullable

Set to true to have a field be able to be inserted into the database with a null value.  Same as the
@code{canBeNull} field in the @code{@@DatabaseField} annotation.

@cindex unique constraint
@cindex constraint, unique
@item unique

Adds a constraint to the field that it has to be unique across all rows in the table.  Same as the
@code{unique} field in the @code{@@DatabaseField} annotation.

@end table

@cindex @@Id
@cindex Id annotation
@cindex id field
@cindex key field
@cindex primary key field
@item @@Id

Used to specify a field to be persisted to the database as a primary row-id.  If you want to have the id be
auto-generated, you will need to also specify the @code{@@GeneratedValue} annotation.

@cindex @@GeneratedValue
@cindex GeneratedValue annotation
@item @@GeneratedValue

Used to define an id field as having a auto-generated value.  This is only used in addition to the @code{@@Id}
annotation.  See the @code{generatedId} field in the @code{@@DatabaseField} annotation for more details.

@cindex @@ManyToOne
@cindex ManyToOne annotation
@cindex @@OneToOne
@cindex OneToOne annotation
@item @@OneToOne or @@ManyToOne

Fields with these annotations are assumed to be foreign fields.  @xref{Foreign Objects}.  ORMLite does
@emph{not} enforce the many or one relationship nor does it use any of the annotation fields.  It just uses the
existence of either of these annotations to indicate that it is a foreign object.

@cindex @@JoinColumn
@cindex JoinColumn annotation
@item @@JoinColumn

@table @code

@item name

Sets the column name of the field.  Same as @code{@@Column@{name=...@}}.

@item nullable

Set to true to have a field be able to be inserted into the database with a null value.  Same as
@code{@@Column@{nullable=...@}}.

@end table

@cindex @@Version
@cindex Version annotation
@item @@Version

Using this annotation will turn short, integer, long, and Date fields into a version field.  @xref{version field}.

@end table

If the @code{@@Column} annotation is used on a field that has a unknown type then it is assumed to be a
@code{Serializable} type field and the object should implement @code{java.io.Serializable}.
@xref{datatype serializable}.

@c ----------------------------------------------------------------
@node No Arg Constructor, Persisted Types, Javax Persistence Annotations, Class Setup
@subsection Adding a No-Argument-Constructor

@cindex no argument constructor
@cindex constructor with no args
After you have added the class and field annotations, you will also need to add a no-argument constructor with
@emph{at least} package visibility.  When an object is returned from a query, ORMLite constructs the object
using Java reflection and a constructor needs to be called.

@example
Account() @{
    // all persisted classes must define a no-arg constructor
    // with at least package visibility
@}
@end example

So your final example Account class with annotations and constructor would look like:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    
    @@DatabaseField(id = true)
    private String name;
    
    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}

    Account() @{
        // all persisted classes must define a no-arg constructor
        // with at least package visibility
    @}
    @dots{}
@}
@end example

@c ----------------------------------------------------------------
@node Persisted Types, Connection Source, No Arg Constructor, Using
@section Persisted Data Types

@cindex persisted types
@cindex types that are persisted
The following Java types can be persisted to the database by ORMLite.  Database specific code
helps to translate between the SQL types and the database specific handling of those types.
@xref{Database Type Details}.

@table @code

@cindex String
@cindex VARCHAR string
@anchor{datatype string}
@item String (DataType.STRING)

Persisted as SQL type @code{VARCHAR}.  

@cindex long string
@item String (DataType.LONG_STRING)

Persisted as SQL type @code{LONGVARCHAR} which handles longer strings.  

@cindex string byte array
@cindex  byte array string
@cindex STRING_BYTES
@cindex unicode strings, storing
@cindex accented strings, storing
@item String (DataType.STRING_BYTES)

A Java String persisted as an array of bytes (@code{byte[]}) with the SQL type @code{VARBINARY}.  Many databases are
Unicode compliant (MySQL/Postgres) but some are not (SQLite).  To store strings with accents or other special
characters, you may have to encode them as an array of bytes using this type.  By default the @code{Unicode}
@code{Charset} is used to convert the string to bytes and back again.  You can use the @code{format} field in
@code{DatabaseField} to specify a custom character-set to use instead for the field.  Comparison and ordering
of this type may not be possible depending on the database type.

@cindex boolean
@anchor{datatype boolean}
@item boolean or Boolean (DataType.BOOLEAN or DataType.BOOLEAN_OBJ)

Persisted as SQL type @code{BOOLEAN}.

@cindex boolean character
@item boolean or Boolean (DataType.BOOLEAN or DataType.BOOLEAN_OBJ) as a character

Persisted as SQL type @code{BOOLEAN}.

@cindex boolean integer
@item boolean or Boolean (DataType.BOOLEAN or DataType.BOOLEAN_OBJ) as an integer

Persisted as SQL type @code{INTEGER}.  False is 0 and every other value is true.

@cindex byte
@anchor{datatype byte}
@item byte or Byte (DataType.BYTE or DataType.BYTE_OBJ)

Persisted as SQL type @code{TINYINT}.

@cindex byte array
@cindex array of bytes
@anchor{BYTE_ARRAY}
@item byte array (DataType.BYTE_ARRAY)

Array of bytes (byte[]) persisted as SQL type @code{VARBINARY}.  This is different from the @code{DataType.SERIALIZABLE} type which 
serializes an object as an array of bytes.

@emph{NOTE:} Because of backwards compatibility, any fields that are of type @code{byte[]} @emph{must} be specified as
@code{DataType.BYTE_ARRAY} or @code{DataType.SERIALIZABLE} using the @code{dataType} field and will not be auto-detected.
@xref{DatabaseField dataType}.

@example
@@DatabaseField(dataType = DataType.BYTE_ARRAY)
byte[] imageBytes;
@end example

@cindex char
@item char or Character (DataType.CHAR or DataType.CHAR_OBJ)

Persisted as SQL type @code{CHAR}.

@emph{NOTE:} If you are using Derby you should consider using a String instead since comparisons of character fields are
not allowed.

@cindex short
@anchor{datatype short}
@item short or Short (DataType.SHORT or DataType.SHORT_OBJ)

Persisted as SQL type SMALLINT.

@cindex int
@anchor{datatype int}
@item int or Integer (DataType.INTEGER or DataType.INTEGER_OBJ)

Persisted as SQL type @code{INTEGER}.

@cindex long
@anchor{datatype long}
@item long or Long (DataType.LONG or DataType.LONG_OBJ)

Persisted as SQL type @code{BIGINT}.

@cindex float
@anchor{datatype float}
@item float or Float (DataType.FLOAT or DataType.FLOAT_OBJ)

Persisted as SQL type @code{FLOAT}.

@cindex double
@anchor{datatype double}
@item double or Double (DataType.DOUBLE or DataType.DOUBLE_OBJ)

Persisted as SQL type @code{DOUBLE}.

@cindex Serializable
@cindex persist objects
@anchor{datatype serializable}
@item Serializable (DataType.SERIALIZABLE)

Persisted as SQL type @code{VARBINARY}.  This is a special type that serializes an object as a sequence of bytes
and then de-serializes it on the way back.  The field must be an object that implements the @code{java.io.Serializable}
interface.  Depending on the database type, there will be limits to the size of the object that can be stored.
This is different from the @code{DataType.BYTE_ARRAY} type which stores the byte array directly.

Some databases place restrictions on this field type that it cannot be the id column in a class.  Other databases do
not allow you to query on this type of field at all.  If your database does support it, you may also have to use a
Select Argument to query for this type.  @xref{Select Arguments}.

@emph{NOTE:} To use this type, you @emph{must} specify @code{DataType.SERIALIZABLE} using the @code{dataType} field.  It will
not be auto-detected.  @xref{DatabaseField dataType}.

@example
// image is an object that implements Serializable
@@DatabaseField(dataType = DataType.SERIALIZABLE)
Image image;
@end example

@cindex Enum string
@cindex Enum name
@cindex enumerated types
@anchor{datatype enum string}
@anchor{datatype enum name}
@item enum or Enum (DataType.ENUM_NAME)

Persisted by default as the enumerated value's string @emph{name} as a @code{VARCHAR} type.  The string name is the
default (and recommended over ENUM_INTEGER) because it allows you to add additional enums anywhere in the list
without worrying about having to convert data later.  Formerly called @code{ENUM_STRING}.

@cindex unknownEnumName
You can also also specify an @emph{unknownEnumName} name with the @code{@@DatabaseField} annotation which will be
used if an unknown value is found in the database. @xref{unknownEnumName}. 

@cindex Enum to-string
@cindex enumerated types
@anchor{datatype enum tostring}
@item enum or Enum (DataType.ENUM_TO_STRING)

Similar to @code{ENUM_STRING} but this is persisted by default as the value from the enum's @code{toString()} method
as opposed to its @emph{name} as a @code{VARCHAR} type.

@cindex Enum integer
@cindex enumerated types
@anchor{datatype enum integer}
@item enum or Enum (DataType.ENUM_INTEGER)

You specify the @code{dataType} field (from the @code{@@DatabaseField} annotation) as a @code{DataType.ENUM_INTEGER} in
which case the @code{ordinal} of the enum value will be stored as an @code{INTEGER}.  The name (ENUM_NAME) is the
default (and recommended) because it allows you to add additional enums anywhere in the list without worrying about
having to convert data later.  If you insert (or remove) an enum from the list that is being stored as a number, then
old data will be un-persisted incorrectly.

@cindex unknownEnumName
You can also also specify an @emph{unknownEnumName} name with the @code{@@DatabaseField} annotation which will be
used if an unknown value is found in the database. @xref{unknownEnumName}. 

@anchor{UUID}
@cindex UUID type
@item UUID (DataType.UUID)

The @code{java.util.UUID} class persisted as a @code{VARCHAR} type.  It saves it as the @code{uuid.toString()} and used the
@code{UUID.fromString(String)} method to convert it back again.  You can also mark a @code{UUID} field as being generated-id
in which case whenever it is inserted, @code{java.util.UUID.randomUUID()} is called and set on the field.
@xref{GeneratedId Column}.

@anchor{UUID_NATIVE}
@cindex UUID native db support
@cindex UUID_NATIVE type
@item UUID (DataType.UUID_NATIVE)

You specify the @code{dataType} field (from the @code{@@DatabaseField} annotation) as a @code{DataType.UUID_NATIVE} 
to persist a @code{UUID} in a database native column format.  This is only supported by a couple of different database
types and is still inserted with JDBC as a string.

@cindex BigIteger type
@item BigInteger (DataType.BIG_INTEGER)

The @code{java.math.BigInteger} class persisted as a @code{VARCHAR} type.  It is saved using the @code{bigInteger.toString()}
and uses the string constructor to convert it back again.

@cindex BigDecimal type
@item BigDecimal (DataType.BIG_DECIMAL)

The @code{java.math.BigDecimal} class persisted as a @code{VARCHAR} type.  It is saved using the @code{bigDecimal.toString()}
and uses the string constructor to convert it back again.

@cindex BigDecimal Numeric type
@item BigDecimal (DataType.BIG_DECIMAL_NUMERIC)

You specify the @code{dataType} field (from the @code{@@DatabaseField} annotation) as a @code{DataType.BIG_DECIMAL_NUMERIC}
in which case a @code{java.math.BigDecimal} field will be persisted as a @code{NUMERIC} type.  This is only supported by some
database types and with various default precision settings.  Android should use the default @code{DataType.BIG_DECIMAL}.

@cindex Date
@cindex java date
@cindex date, java
@anchor{datatype date}
@item java.util.Date (DataType.DATE)

Persisted as SQL type @code{TIMESTAMP}.  This type automatically uses an internal @code{?} argument because the string
format of it is unreliable to match the database format.  @xref{Select Arguments}.  See also @code{DATE_LONG} and
@code{DATE_STRING}.

@emph{NOTE:} This is a different class from @code{java.sql.Date} which is handled by @code{DataType.SQL_DATE}.

@emph{NOTE:} Certain databases only provide seconds resolution so the milliseconds will be 0.

@cindex java long date
@cindex date, java long
@anchor{datatype date long}
@item java.util.Date (DataType.DATE_LONG)

You can also specify the @code{dataType} field to the @code{@@DatabaseField} annotation as a @code{DataType.DATE_LONG}
in which case the milliseconds value of the @code{Date} will be stored as an LONG.  See also @code{DATE} and @code{DATE_STRING}.

@emph{NOTE:} This is a different class from @code{java.sql.Date} which is handled by @code{DataType.SQL_DATE}.

@emph{NOTE:} Certain databases only provide seconds resolution so the milliseconds will be 0.

@cindex Date integer
@cindex java date integer
@cindex date, java integer
@item java.util.Date (DataType.DATE_INTEGER)

Persisted as SQL type @code{INTEGER}.  This stores the date as integer seconds since epoch.

@cindex java string date
@cindex date formats
@anchor{datatype date string}
@item java.util.Date (DATE_STRING)

You can also specify the @code{dataType} field to the @code{@@DatabaseField} annotation as a @code{DataType.DATE_STRING}
in which case the date will be stored as a string in @code{yyyy-MM-dd HH:mm:ss.SSSSSS} format.  You can use the
@code{format} field in @code{DatabaseField} to set the date to another format.  See also @code{DATE} and @code{DATE_LONG}.

@cindex timezone date string
@cindex date string, timezone
@emph{NOTE:} The @code{format} field can start with the special string @code{\{TZ XXX\}} which can be used to specify
the timezone that should be used to store data in the database.  For example: @code{\{TZ GMT\}yyyy-MM-dd HH:mm:ss}.

@emph{NOTE:} This is a different class from @code{java.sql.Date} which is handled by @code{DataType.SQL_DATE}.

@emph{NOTE:} Certain databases only provide seconds resolution so the milliseconds will be 0.

@cindex DateTime Joda type
@cindex Joda DateTime type
@item org.joda.time.DateTime (DataType.DATE_TIME)

This stores the Joda @code{DateTime} into the database as long epoch millis.  This persister uses reflection to avoid
setting up a dependency with Joda jars.  You can define a custom data persister if you want to natively use the class. 
@xref{custom data persister}.

@cindex java.sql.Date type
@cindex SQL Date type
@cindex Date, SQL type
@item java.sql.Date (DataType.SQL_DATE)

Persisted as SQL type @code{TIMESTAMP}.

@emph{NOTE:} This is the @code{java.sql.Date} and not the @code{java.util.Date}.  It is recommended that you use the
@code{java.util.Date} class handled by @code{DataType.DATE} instead.

@cindex Timestamp, SQL type
@cindex SQL Timestamp type
@item java.sql.Timestamp (DataType.TIME_STAMP)

Persisted as SQL type @code{TIMESTAMP}.

@emph{NOTE:} It is recommended that you use the @code{java.util.Date} class instead which is the @code{DataType.DATE} type.

@cindex Timestamp, SQL string type
@cindex SQL Timestamp string type
@item java.sql.Timestamp (DataType.TIME_STAMP_STRING)

Persisted as SQL type @code{TIMESTAMP}.

You can also specify the @code{dataType} field to the @code{@@DatabaseField} annotation as a
@code{DataType.TIME_STAMP_STRING} in which case the date will be stored as a string in
@code{yyyy-MM-dd HH:mm:ss.SSSSSS} format.  You can use the @code{format} field in @code{DatabaseField} to set the
time-stamp to another format.

@emph{NOTE:} It is recommended that you use the @code{java.util.Date} class instead which is the
@code{DataType.DATE_STRING} type.  See also @code{DATE_STRING}.

@cindex Currency
@cindex SQL Timestamp type
@item java.util.Currency (DataType.CURRENCY)

Persisted as SQL type @code{STRING}.

@end table

@emph{NOTE:} ORMLite also supports the concept of foreign objects where the id of another object is
stored in the database.  @xref{Foreign Objects}.

@c ----------------------------------------------------------------
@node Connection Source, DAO Setup, Persisted Types, Using
@section Connection Sources

@emph{NOTE:} With regards to connection sources, Android users should see the Android specific documentation later in the manual.
@xref{Use With Android}.

@cindex data source
@cindex connection source
@cindex database connection
@cindex simple connection source
To use the database and the DAO objects, you will need to configure what JDBC calls a @code{DataSource} (see the
@code{javax.sql.DataSource} class) and what ORMLite calls a @code{ConnectionSource}.  A @code{ConnectionSource} is
a factory for connections to the physical SQL database.  Here is a code example that creates a simple, single-connection
source.

@cindex JdbcConnectionSource
@cindex connection source, simple
@example
// single connection source example for a database URI
ConnectionSource connectionSource =
  new JdbcConnectionSource("jdbc:h2:mem:account");
@end example

@cindex pooled connection source
@cindex connection pooling
The package also includes the class @code{JdbcPooledConnectionSource} which is a relatively simple implementation of a
pooled connection source.  As database connections are released, instead of being closed, they are added to an internal
list so they can be reused at a later time.  New connections are created on demand only if there are no dormant
connections available.  @code{JdbcPooledConnectionSource} is also synchronized and can be used by multiple threads.  It
has settings for the maximum number of free connections before they are closed as well as a maximum age before a
connection is closed.  

@example
// pooled connection source
JdbcPooledConnectionSource connectionSource =
  new JdbcPooledConnectionSource("jdbc:h2:mem:account");
// only keep the connections open for 5 minutes
connectionSource.setMaxConnectionAgeMillis(5 * 60 * 1000);
@end example

@code{JdbcPooledConnectionSource} also has a keep-alive thread which pings each of the dormant pooled connections every so often
to make sure they are valid -- closing the ones that are no long good.  You can also enable the testing of the connection right
before you get a connection from the pool.  See the javadocs for more information.

@example
// change the check-every milliseconds from 30 seconds to 60
connectionSource.setCheckConnectionsEveryMillis(60 * 1000);
// for extra protection, enable the testing of connections
// right before they are handed to the user
connectionSource.setTestBeforeGet(true);
@end example

@cindex other data sources
@cindex external data sources
@cindex use with external data source
@cindex DataSourceConnectionSource
There are many other, external data sources that can be used instead, including more robust and probably higher-performance
pooled connection managers. You can instantiate your own directly and wrap it in the @code{DataSourceConnectionSource} class
which delegates to it.

@cindex BasicDataSource
@example
// basic Apache data source
BasicDataSource dataSource = new BasicDataSource();
String databaseUrl = "jdbc:h2:mem:account";
dataSource.setUrl(databaseUrl);
// we wrap it in the DataSourceConnectionSource
ConnectionSource connectionSource = 
  new DataSourceConnectionSource(dataSource, databaseUrl);
@end example

@cindex close data source
@cindex destroy data source
When you are done with your @code{ConnectionSource}, you will want to call a @code{close()} method to close any
underlying connections.  Something like the following pattern is recommended.

@example
JdbcConnectionSource connectionSource =
    new JdbcPooledConnectionSource("jdbc:h2:mem:account");
try @{
    // work with the data-source and DAOs
    @dots{}
@} finally @{
    connectionSource.close();
@}
@end example

Unfortunately, the @code{DataSource} interface does not have a close method so if you are using the @code{DataSourceConnectionSource}
you will have to close the underlying @code{DataSource} by hand -- the @code{close()} method on the @code{DataSourceConnectionSource}
does @emph{nothing}.

@c ----------------------------------------------------------------
@node DAO Setup, Database Notes, Connection Source, Using
@section Setting Up the DAOs

@cindex DAO setup
@cindex setting up the DAO
@cindex id column
@cindex createDao method
Once you have annotated your classes and defined your @code{ConnectionSource} you will need to create the Data Access Object
(DAO) class(es), each of which will handle all database operations for a single persisted class.  Each DAO has two generic parameters:
the class we are persisting with the DAO, and the class of the ID-column that will be used to identify a specific database row.  If
your class does not have an ID field, you can put @code{Object} or @code{Void} as the 2nd argument.  For example, in the above
@code{Account} class, the "name" field is the ID column (id = true) so the ID class is @code{String}.

@anchor{DaoManager}
The simplest way to create your DAO is to use the @code{createDao} static method on the @code{DaoManager} class to create a
DAO class.  For example:

@example
Dao<Account, String> accountDao =
  DaoManager.createDao(connectionSource, Account.class);
Dao<Order, Integer> orderDao =
  DaoManager.createDao(connectionSource, Order.class);
@end example

@cindex DaoManager
@cindex reusing DAOs
@emph{NOTE:} You should use the @code{DaoManager.createDao()} method to create your DAO classes so if they are needed by internal
ORMLite functionality, they can be reused and not regenerated.  Building a DAO can be an expensive operation and for devices with
limited resources (like mobile apps), DAOs should be reused if at all possible.

@cindex Dao interface
If you want a better class hierarchy or if you need to add additional methods to your DAOs, you should consider defining
an interface which extends the @code{Dao} interface.  The interface isn't required but it is a good pattern so your code is
less tied to JDBC for persistence.  The following is an example DAO interface corresponding to the Account class from the
previous section of the manual:

@example
/** Account DAO which has a String id (Account.name) */
public interface AccountDao extends Dao<Account, String> @{
    // empty wrapper, you can add additional DAO methods here
@}
@end example

@cindex BaseDaoImpl base class
Then in the implementation, you should extend the @code{BaseDaoImpl} base class.  Here's the example implementation of your DAO
interface.

@cindex jdbc dao implementation
@example
/** JDBC implementation of the AccountDao interface. */
public class AccountDaoImpl extends BaseDaoImpl<Account, String>
  implements AccountDao @{
    // this constructor must be defined
    public AccountDaoImpl(ConnectionSource connectionSource)
      throws SQLException @{
        super(connectionSource, Account.class);
    @}
@}
@end example

To make use of your custom DAO classes, you need to add the @code{daoClass} field to the @code{@@DatabaseTable} on the corresponding
entity class:

@example
@@DatabaseTable(daoClass = AccountDaoImpl.class)
public class Account @{
   @dots{}
@}
@end example

That's all you need to define your DAO classes.  You are free to add more methods to your DAO interfaces and
implementations if there are specific operations that are needed and not provided by the Dao base classes.
More on how to use these DAOs later. @xref{DAO Usage}.

@emph{NOTE:} If you are using a custom DAO then be sure to add the @code{daoClass} argument to the @code{@@DatabaseTable} annotation
which specifies the class of your custom DAO.  This is used by the DaoManager to instantiate the DAO internally.  @xref{DaoManager}.

@c ----------------------------------------------------------------
@node Database Notes, Complete Wiring, DAO Setup, Using
@section Supported Databases

@cindex database notes
@cindex different databases
ORMLite supports the following database flavors.  Some of them have some specific documentation that needs to be obeyed.

@table @asis

@cindex MySQL database
@item MySQL

Tables are created in MySQL with the InnoDB engine by default using @code{CREATE TABLE ... ENGINE=InnoDB}.  If you want to use
another engine, you can instantiate the @code{MysqlDatabaseType} directly and use the @code{setCreateTableSuffix()} method to use
the default or another engine.  Also, MySQL does some funky stuff with the last-modification time if a @code{Date} is defined as a
@code{TIMESTAMP} so @code{DATETIME} was used instead.

@cindex Postgres database
@item Postgres

No special instructions.

@cindex H2 database
@item H2

No special instructions.  We use this database for all of our internal testing with in-memory and small on-disk databases.

@cindex Xerial SQLite driver
@cindex Zentus SQLite driver
@cindex SQLite database
@item SQLite

There are multiple SQLite drivers out there.  Make sure you use the @uref{http://www.xerial.org/trac/Xerial/wiki/SQLiteJDBC, Xerial driver}
and not the @uref{http://www.zentus.com/sqlitejdbc/, Zentus driver} which does not support generated ids.

If you want to use the internal SQLite time/date functions (such as @code{strftime}) on @code{Date} fields, your fields should
be of type @code{DATE_STRING} to have the dates match in the internal date formats.  For example:

@example
@@DatabaseField(dataType = DataType.DATE_STRING)
private Date date;
@end example

@cindex Android SQLite database
@item Android SQLite

Android's SQLite database is accessed through direct calls to the Android database API methods.

@cindex Derby database
@item Derby

There are two drivers for Derby: one embedded and one client/server.  ORMLite makes an attempt to detect the right driver but you
may have to set the right database type on your ConnectionSource directly if it doesn't.  @xref{Database Type Details}.

@cindex HSQLDB database
@item HSQLDB

No special instructions.

@cindex Microsoft SQL Server database
@cindex SQL Server database
@item Microsoft SQL Server

No special instructions.

@cindex Netezza database
@item Netezza

There is some support for Netezza although it should be considered beta and possibly with bugs.  I do not currently have
access to a server running a Netezza database. We will try to keep this driver up to date with the help of contributors.
Thanks to Richard Kooijman for the driver. Please contact us if you want to help with development of this driver.
  
@cindex ODBC database
@cindex Microsoft ODBC database
@item ODBC

There also some support for ODBC although it should be considered beta and possibly with bugs.  I do not have access to
a server running Microsoft's Open Database Connectivity.  We will try to keep this driver up to date with the help of
contributors.  Thanks to Dale Asberry for the driver.  Please contact us if you want to help with development of this
driver.

@cindex DB2 database
@item DB2

I do not have access to an DB2 database so we cannot run any tests to make sure that our support for it works well.  Please contact
us if you want to help with development of this driver.

@cindex Oracle database
@item Oracle

I do not have access to an Oracle database so we cannot run any tests to make sure that our support for it works well.  Please contact us
if you want to help with development of this driver.

@end table

@cindex database not supported
Please contact the author if your database is not supported.

@c ----------------------------------------------------------------
@node Complete Wiring, Table Creation, Database Notes, Using
@section Tying It All Together

@cindex usage example
So you have annotated the objects to be persisted, added the no-argument constructor, created your @code{ConnectionSource}, and
defined your DAO classes.  You are ready to start persisting and querying your database objects.  You will need to download and add
the H2 jar file to your class-path if you want to run the example as-is.  See the @uref{http://www.h2database.com/html/download.html,
H2 home page}.

The following code ties it all together:

@example
// h2 by default but change to match your database
String databaseUrl = "jdbc:h2:mem:account";
JdbcConnectionSource connectionSource =
  new JdbcConnectionSource(databaseUrl);

// instantiate the dao with the connection source
AccountDaoImpl accountDao = new AccountDaoImpl(connectionSource);

// if you need to create the 'accounts' table make this call
TableUtils.createTable(connectionSource, Account.class);

// create an instance of Account
Account account = new Account("Jim Coakley");

// persist the account object to the database
accountDao.create(account);
@dots{}

// destroy the data source which should close underlying connections
connectionSource.destroy();
@end example

For more examples, see the code later in the manual.  @xref{Examples}.

@c ----------------------------------------------------------------
@node Table Creation, TableUtils, Complete Wiring, Using
@section Table and Schema Creation

@cindex table creation
@cindex schema creation
@cindex creating a table
There a couple of tools that ORMLite provides to help with creating tables and schema for the classes that you are
storing in the database.

@menu
* TableUtils::                 Class which creates and drops tables.
* TableCreator::               Spring class which auto-creates tables.
@end menu

@c ----------------------------------------------------------------
@node TableUtils, TableCreator, Table Creation, Table Creation
@subsection TableUtils Class

@cindex TableUtils
The @code{TableUtils} class provides a number of static methods that help with creating and dropping tables as well as providing
the schema statements.

@table @code

@item createTable(ConnectionSource, Class)

This method takes the @code{ConnectionSource} and a class and creates the table associated with the class.  It uses the annotations
from the class to determine the various fields and characteristics of the table.  It returns the number of statements executed to
create the table.

@example
TableUtils.createTable(connectionSource, Account.class);
@end example

@item createTableIfNotExists(ConnectionSource, Class)

Similar to the last method but it will only create the table if it doesn't exist.  This is not supported on all database types.

@item createTable(ConnectionSource, DatabaseTableConfig)

Similar to the last method but instead of a class, this method uses a @code{DatabaseTableConfig} to determine the various fields and
characteristics of the table.

@example
ArrayList<DatabaseFieldConfig> fieldConfigs =
   new ArrayList<DatabaseFieldConfig>();
fieldConfigs.add(new DatabaseFieldConfig("id", null,
   DataType.UNKNOWN, null, 0, false, false, true, null,
   false, null, false, null, false, null, false, null,
   null, false));
@dots{}
DatabaseTableConfig<Account> tableConfig =
   new DatabaseTableConfig<Account>(Account.class,
     fieldConfigs);
// this returns number of statements executed to create table
TableUtils.createTable(connectionSource, tableConfig);
@end example

@item createTableIfNotExists(ConnectionSource, DatabaseTableConfig)

Similar to the last method but it will only create the table if it doesn't exist.  This is not supported on all database types.

@cindex drop tables
@cindex delete tables
@cindex remove tables
@item dropTable(ConnectionSource, Class, boolean ignoreErrors)

This method drops the table associated with the class.  It uses the annotations from the class to determine the name of the table to
drop. This is not undo-able and most likely will be used only in tests since production tables are dropped rarely.

The ignoreErrors argument is useful when you are dropping a table before you are creating it and the table may not already exist.  If
ignoreErrors is true then any exceptions are swallowed.

@item dropTable(ConnectionSource, DatabaseTableConfig, boolean ignoreErrors)

Same as the previous method but it will use the @code{DatabaseTableConfig} to determine the name of the table to drop.

@item getCreateTableStatements(ConnectionSource, Class)

This is similar to the @code{createTable} method but will return a list of statements that can be used to create a class.  This is
useful if you want to load the schema during some sort of database initialization process.

@item getCreateTableStatements(ConnectionSource, DatabaseTableConfig)

Same as the previous method but with a @code{DatabaseTableConfig} instead.

@cindex clear table
@cindex delete rows in table
@item clearTable(ConnectionSource, Class)

Clear all data out of the table. For certain database types and with large sized tables, which may take a long time. In some
configurations, it may be faster to drop and re-create the table.  This is [obviously] very destructive and is unrecoverable.

@item clearTable(ConnectionSource, DatabaseTableConfig)

Same as the previous method but with a @code{DatabaseTableConfig} instead.

@end table

@c ----------------------------------------------------------------
@node TableCreator, Identity Columns, TableUtils, Table Creation
@subsection TableCreator Class

@cindex TableCreator
The @code{TableCreator} class is engineered for use with Spring but could be useful in other configurations.  It is configured with
the @code{ConnectionSource} and the list of DAOs that are being used by the program.

It will automagically create the tables associated with those DAOs if the system property @code{ormlite.auto.create.tables} is set
with the value "true".  It also will automagically drop the tables that were created if the system property
@code{ormlite.auto.drop.tables} is set with the value "true".  This is especially useful in tests when you are starting with a test
database that needs to get the latest schema but in production you want to make specific schema changes by hand.  You can set the
system properties in your test start scripts but leave them off in the production scripts.

@example
List<Dao<?, ?>> daoList = new ArrayList<Dao<?, ?>>();
daoList.add(accountDao);
@dots{}

TableCreator creator =
   new TableCreator(connectionSource, daoList);
// create the tables if the right system property is set
creator.maybeCreateTables();
@dots{}

// later, we may want to drop the tables that were created 
creator.maybeDropTables();
@end example

For a real life example of using @code{TableCreator} you can @pxref{spring example}.

@c ----------------------------------------------------------------
@node Identity Columns, Id Column, TableCreator, Using
@section Identity Columns

@cindex identity columns
Database rows can be identified by a particular column which is defined as the @emph{identity} column.  Rows do not need to
have an identity column but many of the DAO operations (update, delete, refresh) require an identity column.  The identity can
either be supplied by the user or auto-generated by the database.  Identity columns have unique values for every row in the
table and they must exist if you want to query-by-id, delete, refresh, or update a particular row using the DAO.  To
configure a field as an identity field, you should use one (and only one) of the following three settings from
@code{@@DatabaseField}: @code{id}, @code{generatedId}, or @code{generatedIdSequence}.

@menu
* Id Column::                        Using fields with id = true.
* GeneratedId Column::               Using fields with generatedId = true.
* GeneratedIdSequence Column::       Using fields with generatedIdSequence = ...
@end menu

@c ----------------------------------------------------------------
@node Id Column, GeneratedId Column, Identity Columns, Identity Columns
@subsection Fields With id

@cindex identity field
@cindex id column
With our @code{Account} example class, the string @code{name} field has been marked with @code{id = true}.  This means
that the @code{name} is the identity column for the object.  Each account stored in the database must have a unique
value for the @code{name} field -- you cannot have two rows with the name "John Smith".

@example
public class Account @{
    @@DatabaseField(id = true)
    private String name;
    @dots{}
@}
@end example

When you use the DAO to lookup an account with a particular name, you will use the identity field to locate the
@code{Account} object in the database:

@example
Account account = accountDao.queryForId("John Smith");
if (account == null) @{
    // the name "John Smith" does not match any rows
@}
@end example

@cindex updateId
@cindex change id value
@cindex update identity of object
@emph{NOTE:} If you need to change the value of an object's id field, you must use the @code{Dao.updateId()} method which
takes the current object still with its @emph{old} id value and the new value.  ORMLite has to first locate the object
by its old id and then update it with the new id.  @xref{updateId}.

@c ----------------------------------------------------------------
@node GeneratedId Column, GeneratedIdSequence Column, Id Column, Identity Columns
@subsection Fields With generatedId

@cindex generated identity field
@cindex generatedId column
You can configure a long or integer field to be a @emph{generated} identity column.  The id number column for each row
will then be automatically generated by the database.  

@example
public class Order @{
    @@DatabaseField(generatedId = true)
    private int id;
    @dots{}
@}
@end example

When an @code{Order} object is passed to @code{create} and stored to the database, the generated identity value is returned
by the database and set on the object by ORMLite.  In the majority of database types, the generated value starts at
1 and increases by 1 every time a new row is inserted into the table.

@example
// build our order object without an id
Order order = new Order("Jim Sanders", 12.34);
@dots{}
orderDao.create(order);
System.out.println("Order id " + order.getId() +
   " was persisted to the database");
// query for the order with an id of 1372
order = orderDao.queryForId(1372);
if (order == null) @{
   // none of the order rows have an id of 1372
@}
@end example

In the above code example, an order is constructed with name and amount (for example).  When it is passed to the DAO's
@code{create} method, the id field has not been set.  After it has been saved to the database, the generated-id will
be set on the id field by ORMLite and will be available when @code{getId()} is called on the order after the
@code{create} method returns.

@emph{NOTE:} Other special field types such as @code{UUID} can also be generated.  @xref{UUID}.

@emph{NOTE:} You can use the @code{allowGeneratedIdInsert} field setting to allow insert objects into a table with or without
an id already set.  @xref{allowGeneratedIdInsert}.

@emph{NOTE:} Depending on the database type, you may not be able to change the value of an auto-generated id field.

@c ----------------------------------------------------------------
@node GeneratedIdSequence Column, DAO Usage, GeneratedId Column, Identity Columns
@subsection Fields With generatedIdSequence

@cindex generated identity sequence name
@cindex generatedIdSequence column

Some databases use what's called a sequence number generator to provide the generated id value.  If you use
@code{generatedId = true} with those databases, a sequence name will be auto-generated by ORMLite.
If, however, you need to set the name of the sequence to match existing schema, you can used the
@code{generatedIdSequence} value which takes a string name for the sequence.

@example
public class Order @{
    @@DatabaseField(generatedIdSequence = "order_id_seq")
    private int id;
    @dots{}
@}
@end example

In the above example, the @code{id} value is again automatically generated but using a sequence with the name
@code{order_id_seq}.  This will throw an exception if you are working with a database which does not support
sequences.

@emph{NOTE:} Depending on the database type, you may not be able to change the value of an auto-generated id field.

@c ----------------------------------------------------------------
@node DAO Usage, Creating Indexes, GeneratedIdSequence Column, Using
@section DAO Usage

@cindex DAO usage
@cindex using the DAOs

The following database operations are easily accomplished by using the DAO methods:

@table @asis

@cindex creating a database row
@cindex saving an object
@cindex persisting an object
@cindex writing an object
@item create and persist an object to the database

This inserts a new row to the database table associated with the object.

@example
Account account = new Account();
account.name = "Jim Coakley";
accountDao.create(account);
@end example

@cindex query for id
@item query for it's id column 

If the object has an id field defined by the annotations, then we can lookup an object in the database using its id.

@example
Account account = accountDao.queryForId(name);
if (account == null) @{
  account not found handling @dots{} 
@}
@end example

@cindex updating an object
@item update the database row associated with the object

If you change fields in an object in memory, you must call update to persist those changes to the database.  This
requires an id field. 

@example
account.password = "_secret";
accountDao.update(account);
@end example

@cindex refreshing an object
@item refreshing an object if the database has changed

If some other entity has changed a row the database corresponding to an object in memory, you will need to refresh that
object to get the memory object up-to-date.  This requires an id field. 

@example
accountDao.refresh(account);
@end example

@cindex deleting an object
@item delete the account from the database

Removes the row that corresponds to the object from the database.  Once the object has been deleted from the database,
you can continue to use the object in memory but any update or refresh calls will most likely fail.  This requires an id
field.

@example
accountDao.delete(account);
@end example

@cindex iterator
@cindex iterating through all rows
@anchor{iterator}
@item iterate through all of the rows in a table:

The DAO is also an iterator so you can easily run through all of the rows in the database:

@example
// page through all of the accounts in the database
for (Account account : accountDao) @{
    System.out.println(account.getName());
@}
@end example

@cindex closing an iterator
@emph{NOTE:} you must page through @emph{all} items for the iterator to close the underlying SQL object.   If you don't
go all of the way through to the loop, ORMLite does not know to close the underlying object, and a connection to the database
may be leaked that will only be closed if the garbage collector reaps some time later which may cause bugs in your code.
Use the @code{try ... finally} wrapped iterator patterns below.

For example, the following @code{for} loop is a very bad pattern.

@example
for (Account account : accountDao) @{
    if (account.getName().equals("Bob Smith")) @{
        // you can't return, break, or throw from here
        return account;
    @}
@}
@end example

This also may happen if an exception is thrown out of the loop so @code{for} loops should not be used in these cases.
This is also the case with lazy loaded collections.  @xref{lazy collection iterator}.  

@item use the iterator directly

You can also use the iterator directly because the @code{for} loops are not optimal.  This allows you to use
@code{try ... finally} which is a much better pattern.

@example
CloseableIterator<Account> iterator =
    accountDao.closeableIterator();
try @{
    while (iterator.hasNext()) @{
        Account account = iterator.next();
        System.out.println(account.getName());
    @}
@} finally @{
    // close it at the end to close underlying SQL statement
    iterator.close();
@}
@end example

@cindex wrapped iterable
@cindex CloseableWrappedIterable
@item get a "wrapped iterable"

You can also use the "wrapped iterable" which allows you to do the close in the finally while still using @code{for} loops.

@example
CloseableWrappedIterable<Account> wrappedIterable =
    accountDao.getWrappedIterable();
try @{
    for (Account account : wrappedIterable) @{
        @dots{}
    @}
@} finally @{
    wrappedIterable.close();
@}
@end example

@end table

For a detailed list of the methods in the DAO @pxref{DAO Methods}.

@c ----------------------------------------------------------------
@node Creating Indexes, Raw Statements, DAO Usage, Using
@section Indexing Fields

@cindex indexing fields
ORMLite provides some limited support for indexing of various fields in your data classes.  First off, it
is important to point out that any field marked as an @code{id} field is already indexed.  Fields that are id fields
do not need to have additional indexes built and if they are specified, errors may result with certain database.

To add an index on a non-id field, all you need to do is add the @code{index = true} boolean field to the
@code{@@DatabaseField} annotation.  @xref{index}.  This will create a non-unique index after the table is created 
for the field and will drop the index if the table is then dropped.  Indexes help optimize queries and can
significantly improve times on queries to medium to large sized tables.

@example
public class Account @{
    @@DatabaseField(id = true)
    private String name;
    // this indexes the city field so queries on city
    // will go faster for large tables
    @@DatabaseField(index = true)
    private String city;
    @dots{}
@}
@end example 

This example creates the index @code{account_city_idx} on the Account table.  If you want to use a different name, you
can use the @code{indexName = "othername"} field instead which allows you to specify the name of the index.

If you often query on (for example) city @emph{and} state fields together, you might want to create an index
on both fields.  ORMLite supports creating indexes on multiple fields by specifying the same @code{indexName}
value for each of the fields you want to be included in the index.

@example
@@DatabaseField(indexName = "account_citystate_idx")
private String city;
@@DatabaseField(indexName = "account_citystate_idx")
private String state;
@end example

This example will create one index for both the city and state fields.  Note that queries on the city by itself will
@emph{not} be optimized -- only queries on @emph{both} city and state will be.  With some databases, it may be better to
create a single field index on each field and let the database use both indexes if you are querying on city and state.
For other databases, creating an index on multiple fields is recommended. You may need to experiment and use the SQL
@code{EXPLAIN} command to pinpoint how your database is utilizing your indexes.

To create @emph{unique} indexes, there is a @code{uniqueIndex = true} and @code{uniqueIndexName = "othername"} fields
also available on the @code{@@DatabaseField} annotation.  These work the same as the above settings but will instead
create unique indexes that ensure that no two row has the same value(s) for the indexed field(s).

@c ----------------------------------------------------------------
@node Raw Statements, Raw Queries, Creating Indexes, Using
@section Issuing Raw SQL Statements

@cindex raw SQL statements
@cindex SQL statements, raw
@cindex execute native SQL
In a number of instances, using the defined DAO functionality may not be enough to change your database.  For this
reason, ORMLite has calls which allow you to issue raw query, update, and execute statements to the database.

@menu
* Raw Queries::                Running raw queries against the database.
* Raw Updates::                Updating the database with raw SQL statements.
* Raw Executes::               Executing other raw SQL statements.
@end menu

@c ----------------------------------------------------------------
@node Raw Queries, Raw Updates, Raw Statements, Raw Statements
@subsection Issuing Raw Queries

@cindex raw queries
@cindex native queries
@cindex aggregate, raw queries
@cindex SUM, using
@cindex COUNT, using
@cindex AVG, using
@cindex queryForAllRaw
@cindex iteratorRaw
@cindex RawResults
@cindex GenericRawResults
The built-in methods available in the @code{Dao} interface and the @code{QueryBuilder} classes don't provide
the ability to handle all types of queries.  For example, aggregation queries (sum, count, avg, etc.) cannot be handled
as an object since every query has a different result list.  To handle these queries, you can issue raw database queries
using the @code{queryRaw} methods on DAO.  These methods return a @code{GenericRawResults} object which represents a
result as an array of strings, array of objects, or user mapped objects.  See the documentation on the
@code{GenericRawResults} object for more details on how to use it, or take a look at the following examples.

@example
// find out how many orders account-id #10 has
GenericRawResults<String[]> rawResults =
  orderDao.queryRaw(
    "select count(*) from orders where account_id = 10");
// there should be 1 result
List<String[]> results = rawResults.getResults();
// the results array should have 1 value
String[] resultArray = results.get(0);
// this should print the number of orders that have this account-id
System.out.println("Account-id 10 has " + resultArray[0] + " orders");
@end example

@cindex raw query using QueryBuilder
@cindex QueryBuilder, raw queries
You can even use the @code{QueryBuilder} to build the raw queries for you if you'd lile using the
@code{prepareStatementString()} method.  @xref{QueryBuilder Basics}.

@example
QueryBuilder<Account, Integer> qb = accountDao.queryBuilder();
qb.where().ge("orderCount", 10);
results = accountDao.queryRaw(qb.prepareStatementString());
@end example

If you want to use the @code{QueryBuilder} with arguments to the raw query then you should do something like:

@example
QueryBuilder<Account, Integer> qb = accountDao.queryBuilder();
// we specify a SelectArg here to generate a ? in statement string below
qb.where().ge("orderCount", new SelectArg());
// the 10 at the end is an optional argument to fulfill SelectArg above
results = accountDao.queryRaw(qb.prepareStatementString(), 10);
@end example

If you want to use the @code{QueryBuilder} with aggregate or other raw/custom arguments do something like the following.
Since there is only one result out you can use the @code{genericRawResults.getFirstResult()} method:

@example
QueryBuilder<Account, Integer> qb = accountDao.queryBuilder();
// select 2 aggregate functions as the return
qb.selectRaw("MIN(orderCount)", "MAX(orderCount)");
// the results will contain 2 string values for the min and max
results = accountDao.queryRaw(qb.prepareStatementString());
String[] values = results.getFirstResult();
@end example

For large numbers of results, you should consider using the @code{iterator()} method on the @code{GenericRawResults} object
which uses database paging.  For example:

@example
// return the orders with the sum of their amounts per account
GenericRawResults<String[]> rawResults =
  orderDao.queryRaw(
    "select account_id,sum(amount) from orders group by account_id");
// page through the results
for (String[] resultArray : rawResults) @{
  System.out.println("Account-id " + resultArray[0] + " has "
    + resultArray[1] + " total orders");
@}
rawResults.close();
@end example

@cindex max function
@cindex query for number
@cindex query single number
@cindex aggregate function, query
If you are just trying to query for a single value (typically an aggregate function like @code{MAX}) then you can
use the @code{queryRawValue(...)} method:

@example
long maxUnits = orderDao.queryRawValue("select max(units) from orders");
@end example

@cindex raw query object[]
If some of your fields cannot be appropriately mapped to strings, you can also return the fields as an @code{Object[]} if you
pass in the types of the resulting columns.  For example:

@example
// return the orders with the sum of their amounts per account
GenericRawResults<Object[]> rawResults =
  orderDao.queryRaw(
    "select account_id,sum(amount) from orders group by account_id",
    new DataType[] @{ DataType.LONG, DataType.INTEGER @});
// page through the results
for (Object[] resultArray : rawResults) @{
  System.out.println("Account-id " + resultArray[0] + " has "
    + resultArray[1] + " total orders");
@}
rawResults.close();
@end example

@emph{NOTE}: @code{select *} can return fields in different orders depending on the database type.  To make sure that the data-type
array matches the returned columns you must specify the fields specifically and @emph{not} with a SQL @code{*}.

@cindex map raw query objects
@cindex raw row mapper
You can also map the results into your own object by passing in a @code{RawRowMapper} object.  This will call the mapping object
with an array of strings and allow it to convert the strings into an object.  The DAO provides a default @code{RawRowMapper} that
can be gotten from @code{orderDao.getRawRowMapper()} that knows how to convert the string array into the object.

You can also define your own custom mapper if the results are more complex.  For example:

@example
// return the orders with the sum of their amounts per account
GenericRawResults<Foo> rawResults =
  orderDao.queryRaw(
    "select account_id,sum(amount) from orders group by account_id",
    new RawRowMapper<Foo>() @{
            public Foo mapRow(String[] columnNames,
              String[] resultColumns) @{
                return new Foo(Long.parseLong(resultColumns[0]),
                    Integer.parseInt(resultColumns[1]));
        @}
    @});
// page through the results
for (Foo foo : rawResults) @{
  System.out.println("Account-id " + foo.accountId + " has "
    + foo.totalOrders + " total orders");
@}
rawResults.close();
@end example

@emph{NOTE}: The query and the resulting strings can be @emph{very} database-type specific.  For example:
@enumerate
@item Certain databases need all column names specified in uppercase -- others need lowercase.
@item You may have to quote your column or table names if they are reserved words.
@item The resulting column names also could be uppercase or lowercase again depending on the database type.
@item @code{select *} can return fields in a different order than you expect.
@end enumerate

@emph{NOTE}: Like other ORMLite iterators, you will need to make sure you iterate through all of the results
to have the statement closed automatically.  You can also call the @code{rawResults.close()} method to make sure the
iterator, and any associated database connections, is closed.

@emph{NOTE:} If you are using the @code{QueryBuilder#prepareStatementString()} method to build your query, the
@code{QueryBuild} may have added the id column to the selected column list if the Dao object has an id you did not include
it in the columns you selected. This means that your results may have one more column than you are expecting.

@cindex ResultSet mapping
@cindex DatabaseResults mapping
@cindex raw row mapper
Another way that you can map the results is by using a @code{DatabaseResultsMapper} object.  This will call the mapping object
with the internal @code{DatabaseResults} object to map a row and output an object.  If you are using this with JDBC, then
you you can case the @code{DatabaseResults} to be a @code{JdbcDatabaseResults}.  This will give you access to the
@code{JdbcDatabaseResults.getResultSet()} method and the underlying JDBC result object.  For example:

@example
// return the orders with the sum of their amounts per account
GenericRawResults<Foo> rawResults =
  orderDao.queryRaw(
    "select account_id,sum(amount) from orders group by account_id",
    new RawRowMapper<Foo>() @{
            public Foo mapRow(DatabaseResults results) @{
                ResultSet resultSet = 
                   ((JdbcDatabaseResults)results).getResultSet();
                // now you can use the ResultSet to build Foo
                @dots{}
        @}
    @});
// page through the results
for (Foo foo : rawResults) @{
  System.out.println("Account-id " + foo.accountId + " has "
    + foo.totalOrders + " total orders");
@}
rawResults.close();
@end example

@c ----------------------------------------------------------------
@node Raw Updates, Raw Executes, Raw Queries, Raw Statements
@subsection Issuing Raw Update Statements

@cindex raw update statements
@cindex update with raw sql
You can also issue raw update statements against the database if the DAO functionality does not give you
enough flexibility.  Update SQL statements must contain the reserved words @code{INSERT}, @code{DELETE}, or
@code{UPDATE}.  For example:

@example
fooDao.updateRaw("INSERT INTO accountlog (account_id, total) "
   + "VALUES ((SELECT account_id,sum(amount) FROM accounts))
@end example

@c ----------------------------------------------------------------
@node Raw Executes, Foreign Objects, Raw Updates, Raw Statements
@subsection Issuing Raw Execute Statements

@cindex raw execute statements
@cindex execute raw sql statements
You can also issue raw update statements against the database if the DAO functionality does not give you
enough flexibility.  For example:

@example
fooDao.executeRaw("ALTER TABLE accountlog DROP COLUMN partner");
@end example

@c ----------------------------------------------------------------
@node Foreign Objects, Foreign Collection, Raw Executes, Using
@section Foreign Object Fields

@cindex foreign objects
ORMLite supports the concept of "foreign" objects where one or more of the fields correspond to an object
are persisted in another table in the same database.  For example, if you had an @code{Order} objects in your database
and each @code{Order} had a corresponding @code{Account} object, then the @code{Order} object would have foreign
@code{Account} field.  With foreign objects, @emph{just} the id field from the @code{Account} is persisted
to the @code{Order} table as the column "@code{account_id}".  For example, the @code{Order} class might look
something like:

@example
@@DatabaseTable(tableName = "orders")
public class Order @{

    @@DatabaseField(generatedId = true)
    private int id;
    
    @@DatabaseField(canBeNull = false, foreign = true)
    private Account account;
    @dots{}
@}
@end example

When the @code{Order} table was created, something like the following SQL would be generated:

@example
CREATE TABLE `orders`
   (`id` INTEGER AUTO_INCREMENT , `account_id` INTEGER,
    PRIMARY KEY (`id`)); 
@end example

@emph{Notice} that the name of the field is @emph{not} @code{account} but is instead @code{account_id}.  You will need to
use this field name if you are querying for it.  You can set the column name using the @code{columnName} field in the
@code{DatabaseField} annotation. @xref{columnName}.

@cindex creating objects with foreign fields
@cindex foreign objects, creating
When you are creating a field with a foreign object, please note that the foreign object will @emph{not} automatically be
created for you.  If your foreign object has a generated-id which is provided by the database then you need to create it
@emph{before} you create any objects that reference it.  For example:

@example
Account account = new Account("Jim Coakley");
accountDao.create(account);
// this will create the account object and set any generated ids

// now we can set the account on the order and create it
Order order = new Order("Jim Sanders", 12.34);
order.setAccount(account);
@dots{}
orderDao.create(order);
@end example

If you want some level of auto creation, then you can use the @code{foreignAutoCreate} setting. @xref{foreignAutoCreate}.

@cindex refreshing foreign objects
@cindex foreign object refreshing
When you query for an order, you will get an @code{Order} object with an account field object that @emph{only} has its id
field set.  The rest of the fields in the foreign @code{Account} object will have default values (null, 0, false, etc.).  If
you want to use other fields in the @code{Account}, you must call @code{refresh} on the @code{accountDao} class to get the
@code{Account} object filled in.  For example:

@example
Order order = orderDao.queryForId(orderId);
System.out.println("Account-id on the order should be set: " +
   order.account.id);
// this should print null for order.account.name
System.out.println("But other fields on the account should not be set: "
   + order.account.name);

// so we refresh the account using the AccountDao
accountDao.refresh(order.getAccount());
System.out.println("Now the account fields will be set: " +
   order.account.name);
@end example

You can have the foreign objects automagically refreshed by using the @code{foreignAutoRefresh} setting. @xref{foreignAutoRefresh}.

@emph{NOTE:} Because we use refresh, foreign objects are therefor @emph{required} to have an id field.

@cindex querying for foreign fields
@cindex foreign field querying
You can query for foreign fields in a couple of different ways.  The following examples show code which queries for all orders that
match a certain account field.  Since the id field is the name field, you can query by the name field of the account:

@example
// query for all orders that match a certain account
List<Order> results =
  orderDao.queryBuilder().where().
    eq("account_id", account.getName()).query();
@end example

Or you can just let ORMLite extract the id field from the account itself.  This will perform an equivalent query to the above:

@example
// ORMLite will extract and use the id field internally
List<Order> results =
  orderDao.queryBuilder().where().
    eq("account_id", account).query();
@end example

There is example code to show how to use foreign objects.  @xref{foreign objects example}.

@c ----------------------------------------------------------------
@node Foreign Collection, DAO Enabled Objects, Foreign Objects, Using
@section Foreign Collections

@cindex foreign collections
@cindex eager load collections
@cindex lazy load collections
@cindex collections of objects
@cindex list of objects
In the above section of the manual we gave the example of the @code{Order} class having a foreign object field to the @code{Account}
table.  A foreign collection allows you to add a collection of orders on the account table.  Whenever an @code{Account} object is
returned by a query or refreshed by the DAO, a @emph{separate} query is made over the order table and a collection of orders is set
on the account.  All of the orders in the collection have a corresponding foreign object that matches the account.  For example:

@example
public class Account @{
    @dots{}
    @@ForeignCollectionField(eager = false)
    ForeignCollection<Order> orders;
    @dots{}
@}
@end example

@cindex ForeignCollectionField annotation
@anchor{ForeignCollectionField}
In the above example, the @code{@@ForeignCollectionField} annotation marks that the @code{orders} field is a collection of the orders
that match the account.  The field type of @code{orders} must be either @code{ForeignCollection<T>} or @code{Collection<T>} -- no
other collections are supported because they are much heavier with many methods to support.  The @code{@@ForeignCollectionField}
annotation supports the following fields:

@table @code

@cindex eager versus lazy collection
@item eager

There are two different types of foreign collections: eager or lazy.   If eager is set to true then the separate query is made immediately
and the orders are stored as a list within the collection.  If eager is set to false (the default) then the collection is considered to be
"lazy" and will iterate over the database using the @code{Dao.iterator()} only when a method is called on the collection.

@emph{WARNING:} By default, if you have eager collections of objects that themselves have eager collections, the inner collection will be created
as lazy for performance reasons.  If you need change this see the @code{maxEagerLevel} setting below.

@cindex max eager foreign collection level
@cindex limiting eager foreign collections
@item maxEagerLevel

This can be set to the number of times to expand an eager foreign collection's foreign collection. If you query for A and it has an eager
foreign-collection of field B which has an eager foreign-collection of field C (@dots{}), then a lot of database operations are going to
happen whenever you query for A. By default this value is 1 meaning that if you query for A, the collection of B will be eager fetched but
each of the B objects will have a lazy collection instead of an eager collection of C. It should be increased only if you know what you are
doing.

@cindex foreign collection column name
@cindex empty foreign collection
@item columnName

The name of the column.  This is only used if you want to match the string passed to @code{Dao.assignEmptyForeignCollection(Object, String)} or to
specify that you want the collection returned when you specify @code{queryBuilder.selectColumns(...)}.  @xref{selectColumns}.

@cindex ordered foreign collection
@cindex foreign collection, ordered
@item orderColumnName

The name of the column in the foreign object that we should order the collection by.

@item orderAscending

If an order column has been defined with the above @code{orderColumnName}, this sets the order as ascending (true which is the
default) or descending (false).

@item foreignFieldName

Name of the @emph{field} (not the column name) in the class that the collection is holding that corresponds to the
collection. This is needed if there are two foreign fields in the class in the collection (such as a tree
structure) and you want to identify which column you want in this collection.

@emph{WARNING:} Due to some internal complexities, this it field/member name in the class and @emph{not} the
column-name.

@end table

Remember that when you have a @code{ForeignCollection} field, the class in the collection @emph{must} (in this example Order) must
have a foreign field for the class that has the collection (in this example Account).  If Account has a foreign collection of Orders,
then Order must have an Account foreign field.  It is required so ORMLite can find the orders that match a particular account.   

@emph{WARNING:} With lazy collections, even the @code{size()} method causes a iteration across the database.  You'll most likely want
to just use the @code{iterator()} and @code{toArray()} methods on lazy collections.

@anchor{lazy collection iterator}
@emph{NOTE:} Like with the @code{Dao.iterator()} method, the iterator returned by a lazy collection must be closed when you are done
with it because there is a connection open to the database underneath.  A close happens either if you go all of the way through the
iterator or if you call @code{close()} on it.  Only the @code{ForeignCollection} returns a closeable iterator.   This means that
@code{for} loops across lazy loaded collections are a bad pattern.  For more details about iterating across lazy collections, see
the iterator documentation.  @xref{iterator}.

The foreign collections support the @code{add()} and @code{remove()} methods in which case the objects will be both added or removed
from the internal list if the collection is eager, and DAO calls will be made to affect the order table as well for both eager and
lazy collections.

@emph{NOTE}: When you are adding a new object to a foreign collection, this will also add it to the database by calling through to 
@code{dao.create(obj)}. If the object has @emph{already} been created in the database then you should instead set the foreign field on
the object and call @code{dao.update(obj)}. If you add it here the DAO will try to create it in the database again which will most
likely cause an error.

@emph{NOTE}: When you call @code{update} on an object with a foreign collection (like @code{Account} above) the objects that are
stored in the collection are @emph{not} automatically written to the database as well.  There is no way for ORMLite to be able to
detect which of the objects has been updated unfortunately.  If you update an object in the collection you should call the
@code{update(data)} method on the @code{ForeignCollection} to make sure that the object is persisted.  For example:

@example
for (Order order : account.orders()) @{
   // if we are changing some field in the order
   order.setAmount(123);
   // then we need to update it in the database
   account.orders.update(order);
@}
@end example

Lastly, there is example code to show how to use foreign collections.  @xref{foreign collections example}.

@c ----------------------------------------------------------------
@node DAO Enabled Objects, Statement Builder, Foreign Collection, Using
@section DAO Enabled Objects

@cindex dao enabled objects
Another ORM pattern is to have the objects perform the database operations on themselves instead of using a
Database Access Object (DAO).  For example, given a data object @code{foo},  you would call @code{foo.refresh()}
instead of @code{fooDao.refresh(foo)}.  The default pattern is to use the Dao classes which allow your data
classes to have their own hierarchy and it isolates the database code in the Daos. However, you are free to use
the @code{BaseDaoEnabled} class if you prefer this pattern.

@cindex BaseDaoEnabled
All classes that are able to refresh (update, delete, etc.) themselves should extend the @code{BaseDaoEnabled} 
class.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account extends BaseDaoEnabled @{

    @@DatabaseField(id = true)
    private String name;

    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}
@end example

To first create the object, you will need to use the DAO object or you will need to set the dao on the object so
that it can self create:

@example
account.setDao(accountDao);
account.create();
@end example

However, whenever an object is returned by ORMLite as query results, the DAO has already been set on the
object it extends the @code{BaseDaoEnabled} class.

@example
Account account = accountDao.queryForId(name);
account.setPassword(newPassword);
account.update();
@end example

This will also work for foreign fields.

@example
Order order = orderDao.queryForId(orderId);
// load all of the fields from the account
order.getAccount().refresh();
@end example

The javadocs for @code{BaseDaoEnabled} will have the most up-to-date list of self operations but right now the
class can do:

@table @code

@item create

To create the object you will need to use the DAO or to call @code{setDao()} on the object.

@item refresh

Refresh the object in case it was updated in the database.

@item update

After you make changes to the object in memory, update it in the database.

@item updateId

If you need to update the id of the object, you must use this method.  You cannot change the id field in the object and
then call the update method because then the object will not be found.

@item delete

Delete it from the database.

@end table

Feedback on this is welcome.

@c ----------------------------------------------------------------
@node Statement Builder, QueryBuilder Basics, DAO Enabled Objects, Top
@chapter Custom Statement Builder

@cindex statement builder
@cindex custom statement builder
The DAOs have methods to query for an object that matches an id field (@code{queryForId}), query for all objects
(@code{queryForAll}), iterating through all of the objects in a table (@code{iterator}), and some other simple martching
methods.  However, for more custom queries, there is the @code{queryBuilder()} method which returns a @code{QueryBuilder}
object for the DAO with which you can construct custom queries to return a sub-set of your tables.

@menu
* QueryBuilder Basics::         How to start using the query builder.
* Building Queries::            How to build simple and complex queries.
* Building Statements::         How to build update and delete statements.
* QueryBuilder Capabilities::   Description of the various QueryBuilder methods.
* Where Capabilities::          Description of the various WHERE methods.
* Select Arguments::            Using arguments to queries.
* Column Arguments::            Using arguments to queries to compare columns.
* Join Queries::                Explaining how to use JOIN queries.
@end menu

@c ----------------------------------------------------------------
@node QueryBuilder Basics, Building Queries, Statement Builder, Statement Builder
@section Query Builder Basics

@cindex custom query builder
@cindex query builder basics
@cindex how to use the query builder
Here's how you use the query builder to construct custom queries.  First, it is a good pattern to
set the column names of the fields with Java constants so you can use them in queries.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    public static final String PASSWORD_FIELD_NAME = "password"; 
    
    @dots{}
    @@DatabaseField(canBeNull = false, columnName = PASSWORD_FIELD_NAME)
    private String password;
    @dots{}
@end example

This allows us to construct queries using the password field name without having the renaming of a field in the future break
our queries.  This should be done @emph{even} if the name of the field and the column name are the same.

@cindex where
@example
// get our query builder from the DAO
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
// the 'password' field must be equal to "qwerty"
queryBuilder.where().eq(Account.PASSWORD_FIELD_NAME, "qwerty");
// prepare our sql statement
PreparedQuery<Account> preparedQuery = queryBuilder.prepare();
// query for all accounts that have "qwerty" as a password
List<Account> accountList = accountDao.query(preparedQuery);
@end example

@cindex prepared statement
You get a @code{QueryBuilder} object from the @code{Dao.queryBuilder()} method, call methods on it to build your custom
query, call @code{queryBuilder.prepare()} which returns a @code{PreparedQuery} object, and then pass the @code{PreparedQuery}
to the DAO's @code{query} or @code{iterator} methods.

As a short cut, you can also call the @code{prepare()} method on the @code{Where} object to do something like the following: 

@example
// query for all accounts that have that password
List<Account> accountList =
   accountDao.query(
      accountDao.queryBuilder().where()
         .eq(Account.PASSWORD_FIELD_NAME, "qwerty")
         .prepare());
@end example

You can use another short cut to call @code{query()} or @code{iterator()} either on the @code{QueryBuilder} or @code{Where}
objects.

@example
// query for all accounts that have that password
List<Account> accountList =
      accountDao.queryBuilder().where()
         .eq(Account.PASSWORD_FIELD_NAME, "qwerty")
         .query();
@end example

@c ----------------------------------------------------------------
@node Building Queries, Building Statements, QueryBuilder Basics, Statement Builder
@section Building Queries

@cindex building queries
There are a couple of different ways that you can build queries.  The @code{QueryBuilder} has been written for ease of use
as well for power users.  Simple queries can be done linearly:

@example
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
// get the WHERE object to build our query
Where<Account, String> where = queryBuilder.where();
// the name field must be equal to "foo"
where.eq(Account.NAME_FIELD_NAME, "foo");
// and
where.and();
// the password field must be equal to "_secret"
where.eq(Account.PASSWORD_FIELD_NAME, "_secret");
PreparedQuery<Account> preparedQuery = queryBuilder.prepare();
@end example

The SQL query that will be generated from the above example will be approximately:

@example
SELECT * FROM account
  WHERE (name = 'foo' AND password = '_secret')
@end example

@cindex chain query methods
If you'd rather chain the methods onto one line (like StringBuilder), this can also be written as:

@example
queryBuilder.where()
  .eq(Account.NAME_FIELD_NAME, "foo")
  .and()
  .eq(Account.PASSWORD_FIELD_NAME, "_secret");
@end example

If you'd rather use parenthesis to group the comparisons properly then you can call:

@example
Where<Account, String> where = queryBuilder.where();
where.and(where.eq(Account.NAME_FIELD_NAME, "foo"),
          where.eq(Account.PASSWORD_FIELD_NAME, "_secret"));
@end example

@cindex complex query
All three of the above call formats produce the same SQL.  For complex queries that mix ANDs and ORs, the last
format may be necessary to get the grouping correct.  For example, here's a complex query:

@example
Where<Account, String> where = queryBuilder.where();
where.or(
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "foo"),
    where.eq(Account.PASSWORD_FIELD_NAME, "_secret")),
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "bar"),
    where.eq(Account.PASSWORD_FIELD_NAME, "qwerty")));
@end example

This produces the following approximate SQL:

@example
SELECT * FROM account
  WHERE ((name = 'foo' AND password = '_secret')
         OR (name = 'bar' AND password = 'qwerty'))
@end example

@cindex RPN queries
@cindex reverse polish notation
If you want to do complex queries linearly, you can even use Reverse Polish Notation (of all things).  There is a
@code{Where.or(int)} and @code{Where.and(int)} methods which do the operation on the previous number of specified clauses.

@example
where.eq(Account.NAME_FIELD_NAME, "foo");
where.eq(Account.PASSWORD_FIELD_NAME, "_secret");
// this does an AND between the previous 2 clauses
// it also puts a clause back on the stack
where.and(2);
where.eq(Account.NAME_FIELD_NAME, "bar"),
where.eq(Account.PASSWORD_FIELD_NAME, "qwerty")));
// this does an AND between the previous 2 clauses
// it also puts a clause back on the stack
where.and(2);
// this does an OR between the previous 2 AND clauses
where.or(2);
@end example

@cindex ORDER BY, SQL
@cindex GROUP BY, SQL
The @code{QueryBuilder} also allows you to set what specific select columns you want returned, specify the 'ORDER BY'
and 'GROUP BY' fields, and various other SQL features (LIKE, IN, >, >=, <, <=, <>, IS NULL, DISTINCT, @dots{}).
@xref{Where Capabilities}. You can also see the javadocs on @code{QueryBuilder} and @code{Where} classes for more
information.  Here's a @uref{http://www.w3schools.com/Sql/, good SQL reference site}.

@c ----------------------------------------------------------------
@node Building Statements, QueryBuilder Capabilities, Building Queries, Statement Builder
@section Building Statements

@cindex deleteBuilder
@cindex updateBuilder
@cindex custom update statements
@cindex custom delete statements
@anchor{DeleteBuilder}
@anchor{UpdateBuilder}
The DAO can also be used to construct custom @code{UPDATE} and @code{DELETE} statements.  Update statements
are used to change certain fields in rows from the table that match the @code{WHERE} pattern -- or update @emph{all}
rows if no @code{where()}. Delete statements are used to delete rows from the table that match the @code{WHERE}
pattern -- or delete @emph{all} rows if no @code{where()}.  

For example, if you want to update the passwords for all of the Accounts in your table that are currently null to
the string "none", then you might do something like the following:

@example
UpdateBuilder<Account, String> updateBuilder =
  accountDao.updateBuilder();
// update the password to be "none"
updateBuilder.updateColumnValue("password", "none");
// only update the rows where password is null
updateBuilder.where().isNull(Account.PASSWORD_FIELD_NAME);
updateBuilder.update();
@end example

With update, you can also specify the update value to be an expression:

@example
// update hasDog boolean to true if dogC > 0
updateBuilder.updateColumnExpression(
  "hasDog", "dogC > 0");
@end example

To help you construct your expressions, you can use the @code{UpdateBuilder}'s escape methods @code{escapeColumnName} and
@code{escapeValue} can take a string or a @code{StringBuilder}.  This will protect you if columns or values are reserved words. 

If, instead, you wanted to delete the rows in the Accounts table whose password is currently null, then you might do
something like the following:

@example
DeleteBuilder<Account, String> deleteBuilder =
  accountDao.deleteBuilder();
// only delete the rows where password is null
deleteBuilder.where().isNull(Account.PASSWORD_FIELD_NAME);
deleteBuilder.delete();
@end example

@c ----------------------------------------------------------------
@node QueryBuilder Capabilities, Where Capabilities, Building Statements, Statement Builder
@section QueryBuilder Capabilities

@cindex QueryBuilder methods
The following are some details about the various method calls on the @code{QueryBuilder} object which build custom
select, delete, and update statements.  See the Javadocs for the @code{QueryBuilder} class for the most up-to-date
information about the available methods.  Most of these methods return the @code{QueryBuilder} object so they can
be chained.

Here's a good @uref{http://www.w3schools.com/sql/sql_select.asp, tutorial of SQL commands}.

@table @code

@cindex distinct
@item distinct()

Add "DISTINCT" clause to the SQL query statement.

@emph{NOTE:} Use of this means that the resulting objects may not have a valid ID column value so cannot be deleted
or updated.

@cindex group by columns
@item groupBy(String columnName) 

This adds a "GROUP" clause to the SQL query statement for the specified column name.  This can be called multiple
times to group by multiple columns.

@emph{NOTE:} Use of this means that the resulting objects may not have a valid ID column value so cannot be deleted
or updated.

@cindex group by raw SQL
@item groupByRaw(String sql)

Add a raw SQL "GROUP BY" clause to the SQL query statement. This allows you to group by things that are not just column
names.  The SQL argument should not include the "GROUP BY" string.

@cindex having raw SQL
@item having(String sql)

Add a raw SQL "HAVING" clause to the SQL query statement. This allows you to apply filters after the WHERE and other
matching has been completed.  This is usually done with aggregate functions.  The SQL argument should not include the
"HAVING" string.

@cindex join query
@cindex inner join query
@item join(QueryBuilder joinedQueryBuilder)

Join with another query builder. This will add into the SQL something close to "INNER JOIN other-table ...".
Either the object associated with the current query builder or the argument query builder @emph{must} have a foreign field
of the other one. An exception will be thrown otherwise.  This can be called multiple times to join with more than one
table.

@cindex left join query
@item leftJoin(QueryBuilder joinedQueryBuilder)

Same as @code{join(QueryBuilder)} but it will use "LEFT JOIN" instead.  See:
@uref{http://www.w3schools.com/sql/sql_join_left.asp, LEFT JOIN SQL documentation}.

@emph{NOTE:} @code{RIGHT} and @code{FULL JOIN} SQL commands are not supported because we are only returning objects from
the "left" table.

@cindex limit
@item limit(Integer maxRows)

Limit the output to maxRows maximum number of rows. Set to null for no limit (the default).

@cindex offset
@item offset(Integer startRow)

Start the output at this row number. Set to null for no offset (the default). If you are paging through a table,
you should consider using the @code{Dao.iterator()} method instead which handles paging with a database cursor.
Otherwise, if you are paging you probably want to specify a column to @code{orderBy}.

@emph{NOTE:} This is not supported for all databases. Also, for some databases, the limit @emph{must} also be
specified since the offset is an argument of the limit.

@cindex order by columns
@item orderBy(String columnName, boolean ascending)

Add "ORDER BY" clause to the SQL query statement to order the results by the specified column name.  Use the ascending
boolean to get a ascending or descending order.  This can be called multiple times to group by multiple columns.

@cindex order by nulls first
@item orderByNullsFirst(String columnName, boolean ascending)

Add "ORDER BY" clause to the SQL query statement with a column-name and ascending (if true) with a NULLS FIRST
qualifier. This may not be supported by all database types.

@cindex order by nulls last
@item orderByNullsLast(String columnName, boolean ascending)

Add "ORDER BY" clause to the SQL query statement with a column-name and ascending (if true) with a NULLS LAST
qualifier. This may not be supported by all database types.

@cindex order by raw SQL
@item orderByRaw(String sql)

Add a raw SQL "ORDER BY" clause to the SQL query statement. This allows you to order by things that are not just columns
but can include calculations.  The SQL argument should not include the "ORDER BY" string.

@cindex prepare the query
@item prepare()

Build and return a prepared query that can be used by @code{Dao.query(PreparedQuery)} or
@code{Dao.iterator(PreparedQuery)} methods. If you change the where or make other calls you will need
to re-call this method to re-prepare the statement for execution.

@anchor{selectColumns}
@cindex select columns
@item selectColumns(String... columns)

@cindex lazy load fields
@cindex partial fields returned
Add columns to be returned by the SELECT query and set on any resulting objects. If no columns are selected then
all columns are returned by default. For classes with id columns, the id column is added to the select list
automagically.  All fields not selected in the object with be their default values (null, 0, false, etc.).  

This allows you to in effect have lazy loaded fields.  You can specify exactly which fields to be set on the
resulting objects. This is especially helpful if you have large fields in a table that you don't always
want to access.  To get all of the fields on the object later, you can either do another query or call
@code{refresh()} with the object.  This can be called multiple times to add more columns to select.

@emph{WARNING:} If you specify any columns to return, then any foreign-collection fields will be returned as null
@emph{unless} their @code{ForeignCollectionField.columnName} is also in the list.  @xref{ForeignCollectionField}.

@item selectColumns(Iterable<String> columns)

Same as the above but with an iterable (such as a collection) instead of a variable list of column names.  This can be
called multiple times to add more columns to select.

@cindex query raw columns
@cindex raw columns, query
@cindex aggregate functions, query
@cindex query for aggregate functions
@item selectRaw(String... columns)

Add raw columns or aggregate functions (COUNT, MAX, ...) to the query. This will turn the query into something
only suitable for using as a raw query. This can be called multiple times to add more columns to select.
@xref{Raw Queries}.

@cindex where method
@item where()

Build and return the @code{Where} object with which you can customize your @code{WHERE} SQL statements.
@xref{Where Capabilities}.

@item query()

Convenience method to perform the query.  Same as @code{dao.query(queryBuilder.prepare())}.

@item queryForFirst()

Convenience method to perform the query and return the first result.  Same as @code{dao.queryForFirst(queryBuilder.prepare())}.

@item queryRawFirst()

Convenience method to perform a raw query on the generated state and then return the first result as a @code{String[]}.
Same as @code{Dao.queryRaw(String)} and @code{GenericRawResults.getFirstResult()}.

@item iterator()

Convenience method to generate the iterator for the query.  Same as @code{dao.iterator(queryBuilder.prepare())}.

@item reset()

Resets all of the settings in the @code{QueryBuilder} so it can be reused.

@end table

@c ----------------------------------------------------------------
@node Where Capabilities, Select Arguments, QueryBuilder Capabilities, Statement Builder
@section Where Capabilities

@cindex where methods
The following are some details about the various method calls for adding @code{WHERE} SQL statements to your custom
select, delete, and update statements.  See the Javadocs for the @code{Where} class for the most up-to-date information
about the available methods.  All of the methods return the @code{Where} object so you can chain them together.

Here's a good @uref{http://www.w3schools.com/sql/sql_where.asp, tutorial of SQL commands}.

@table @code

@cindex AND, SQL
@item and()

Binary @code{AND} operation which takes the previous clause and the next clause and AND's them together.  This is when
you are using inline query calls.

@cindex AND, many arguments
@item and(Where<T, ID> first, Where<T, ID> second, Where<T, ID>... others)

AND operation which takes 2 or more arguments and AND's them together.  This is when you are @emph{not} using inline
query calls but instead want to use standard arguments.

@emph{NOTE:} There is no guarantee of the order of the clauses that are generated in the final query.

@emph{NOTE:} There is an annoying code warning that I get with the usage of this method with more than 2 arguments that can
be ignored. 

@item and(int numClauses)

This method needs to be used carefully. This will absorb a number of clauses that were registered previously with
calls to @code{Where.eq()} or other methods and will string them together with AND's. There is no way to verify the number of
previous clauses so the programmer has to count precisely.

@emph{NOTE:} There is no guarantee of the order of the clauses that are generated in the final query.

@cindex BETWEEN, SQL
@item between(String columnName, Object low, Object high)

Add a BETWEEN clause which makes sure the column is between the low and high parameters.

@cindex =, SQL
@cindex equals, SQL
@item eq(String columnName, Object value)

Add a '=' clause which makes sure the column is equal to the value.

@cindex EXISTS, SQL
@item exists(QueryBuilder<?, ?> subQueryBuilder)

Add a EXISTS clause with a sub-query inside of parenthesis.  This will return returns as long as the inner query returns
results.

@emph{NOTE:} The sub-query will be prepared at the same time that the outside query is.

@cindex >=, SQL
@cindex ge, SQL
@cindex greater than or equal, SQL
@item ge(String columnName, Object value)

Add a '>=' clause which makes sure the column is greater-than or equals-to the value.

@cindex >, SQL
@cindex gt, SQL
@cindex greater than, SQL
@item gt(String columnName, Object value)

Add a '>' clause which makes sure the column is greater-than the value.

@item idEq(ID id)

Add a clause where the ID is equals to the argument.

@item idEq(Dao<OD, ?> dataDao, OD data)

Add a clause where the ID is extracted from an existing object.

@cindex IN, SQL
@item in(String columnName, Iterable<?> objects)

Add a IN clause which makes sure the column is equal-to one of the objects from the @code{Iterable} passed in.  Most likely the
@code{Iterable} should probably be on of the @code{Collection} classes such as a @code{List} or @code{Set}.

@cindex IN, SQL
@item in(String columnName, Object... objects)

Add a IN clause which makes sure the column is equal-to one of the objects passed in.

@cindex IN sub-query, SQL
@cindex inner queries
@cindex sub-queries
@item in(String columnName, QueryBuilder<?, ?> subQueryBuilder)

Add a IN clause which makes sure the column is in one of the columns returned from a sub-query inside of parenthesis.
The @code{QueryBuilder} must return 1 and only one column which can be set with the @code{QueryBuilder.selectColumns(String...)}
method calls. That 1 argument must match the SQL type of the column-name passed to this method.  See also @ref{Join Queries}.

@emph{NOTE:} The sub-query will be prepared at the same time that the outside query is.

@cindex IS NULL, SQL
@cindex null comparison, SQL
@item isNull(String columnName)

Add a 'IS NULL' clause which makes sure the column's value is null. '=' NULL does not work.

@cindex IS NOT NULL, SQL
@cindex null comparison, SQL
@item isNotNull(String columnName)

Add a 'IS NOT NULL' clause so the column must not be null. '<>' NULL does not work.

@cindex <=, SQL
@cindex less than or equals, SQL
@cindex le
@item le(String columnName, Object value)

Add a '<=' clause which makes sure the column is less-than or equals-to the value.

@cindex <, SQL
@cindex less than, SQL
@cindex lt
@item lt(String columnName, Object value)

Add a '<' clause which makes sure the column is less-than the value.

@cindex LIKE, SQL
@item like(String columnName, Object value)

Add a LIKE clause which makes sure the column match the value using '%' patterns.

@cindex <>, SQL
@cindex !=, SQL
@cindex not equal to, SQL
@cindex ne
@item ne(String columnName, Object value)

Add a '<>' clause which makes sure the column is not-equal-to the value.

@cindex NOT, SQL
@item not()

Used to NOT the next clause specified when using inline query calls.

@item not(Where<T, ID> comparison)

Used to NOT the argument clause specified.  This is when you are @emph{not} using inline
query calls but instead want to use standard arguments.

@cindex NOT IN, SQL
@item notIn(String columnName, Iterable<?> objects)

Same as the IN clause but negated.  Results are returned that are not in the objects from the iterator.

@cindex NOT IN, SQL
@item in(String columnName, Object... objects)

Same as IN clause but negated.  Results are returned that are not in the variable array of objects.

@cindex NOT IN sub-query, SQL
@item notIn(String columnName, QueryBuilder<?, ?> subQueryBuilder)

Same as IN clause but negated.  Results are returned that are not in the results from the sub-query.

@cindex OR, SQL
@item or()

Binary @code{OR} operation which takes the previous clause and the next clause and OR's them together.  This is when
you are using inline query calls.

@item or(Where<T, ID> first, Where<T, ID> second, Where<T, ID>... others)

OR operation which takes 2 or more arguments and OR's them together.  This is when you are @emph{not} using inline
query calls but instead want to use standard arguments.

@emph{NOTE:} There is no guarantee of the order of the clauses that are generated in the final query.

@emph{NOTE:} There is an annoying code warning that I get with the usage of this method with more than 2 arguments that can
be ignored. 

@item or(int numClauses)

This method needs to be used carefully. This will absorb a number of clauses that were registered previously with
calls to @code{Where.eq()} or other methods and will string them together with OR's. There is no way to verify the number of
previous clauses so the programmer has to count precisely.

@cindex raw where statement
@item raw(String rawStatement)

Add a raw statement as part of the @code{WHERE} that can be anything that the database supports. Using the more
structured methods above is recommended but this gives more control over the query and allows you to utilize
database specific features.

@item prepare()

A short-cut for calling @code{prepare()} on the original @code{QueryBuilder.prepare()}.  This method returns a
@code{PreparedQuery} object.

@cindex reset Where object
@item reset()

Reset the where object so it can be reused in a new query but with the same @code{QueryBuilder}.

@item query()

Convenience method to perform the query.  Same as @code{queryBuilder.query()} and
@code{dao.query(queryBuilder.prepare())}.

@item queryRaw()

Convenience method to perform the query and return raw results.  Same as @code{queryBuilder.queryRaw()} and
@code{dao.queryRaw(...)}.

@item queryForFirst()

Convenience method to perform the query and return the first result.  Same as @code{queryBuilder.queryForFirst()} and
@code{dao.queryForFirst(queryBuilder.prepare())}.

@item queryRawFirst()

Convenience method to perform the query and return the first raw result.  Same as @code{queryBuilder.queryRawFirst()} and
@code{dao.queryRaw(...)}.

@item countOf()

Convenience method to perform the query and return the number of results.  Same as @code{queryBuilder.countOf()} and
@code{dao.countOf(queryBuilder.prepare())}.

@item iterator()

Convenience method to generate the iterator for the query.  Same as @code{queryBuilder.iterator()} and
@code{dao.iterator(queryBuilder.prepare())}.

@end table

@c ----------------------------------------------------------------
@node Select Arguments, Column Arguments, Where Capabilities, Statement Builder
@section Using Select Arguments

@cindex query arguments
@cindex select arguments
@cindex arguments to queries
@cindex argument placeholders
@cindex placeholders, argument
@cindex question marks, queries
@cindex sql ?
Select Arguments are arguments that are used in WHERE operations can be specified directly as value arguments (as in the
above examples) or as a @code{SelectArg} object.  SelectArgs are used to set the value of an argument at a later time --
they generate a SQL '@code{?}'.

For example:

@example
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
Where<Account, String> where = queryBuilder.where();
SelectArg selectArg = new SelectArg();
// define our query as 'name = ?'
where.eq(Account.NAME_FIELD_NAME, selectArg);
// prepare it so it is ready for later query or iterator calls
PreparedQuery<Account> preparedQuery = queryBuilder.prepare();

// later we can set the select argument and issue the query
selectArg.setValue("foo");
List<Account> accounts = accountDao.query(preparedQuery);
// then we can set the select argument to another
// value and re-run the query
selectArg.setValue("bar");
accounts = accountDao.query(preparedQuery);
@end example

@cindex quotes in queries
@cindex string quoting in queries
@cindex escaping arguments
@cindex SQL injection bugs
It is a common problem for people to try to build queries or other statements with arguments that contain quote
characters.  These quotes can clash with the auto-generated SQL and result in syntax errors.  In these cases a
@code{SelectArg} is required.  If you are passing in arguments from any user-input, you can use @code{SelectArg} to
protect yourself from these so called SQL injection security problems.  Lastly, certain data types use an internal
@code{SelectArg} object because the string value of the object does not reliably match the database form of the object
-- @code{java.util.Date} is one example of such a type.

@emph{NOTE:} @code{SelectArg} objects have protection against being used in more than one column name.  You must
instantiate a new object if you want to use a @code{SelectArg} with another column.

@c ----------------------------------------------------------------
@node Column Arguments, Join Queries, Select Arguments, Statement Builder
@section Using Column Arguments

@cindex ColumnArg
@cindex column arguments
@cindex comparing multiple columns
@cindex table columns comparing
Typically when you use the @code{QueryBuilder} you ae comparing a column and a value.  To compare one column against another
you can use a @code{ColumnArg}.

For example:

@example
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
// list all of the accounts that have the same
// name and password field 
queryBuilder.where().eq(Account.NAME_FIELD_NAME,
    new ColumnArg(Account.PASSWORD_FIELD_NAME));
List<Account> results = queryBuilder.query();
@end example

The @code{ColumnArg} can also take a table-name which is useful with @code{JOIN} queries to compare a column from one table
with one in another table.  @xref{Join Queries}.

For example:

@example
QueryBuilder<Order, Integer> orderQb = orderDao.queryBuilder();
orderQb.where().ge("amount", 100.0F);
QueryBuilder<Account, Integer> accountQb = accountDao.queryBuilder();
// find all accounts who have an order larger than their limit
accountQb.where().gt(Account.MAX_LIMIT_AMOUNT_FIELD,
     new ColumnArg("orders", Order.AMOUNT_FIELD));
// join with the order query
List<Account> results = accountQb.join(orderQb).query();
@end example

@c ----------------------------------------------------------------
@node Join Queries, Use With Android, Column Arguments, Statement Builder
@section Building Join Queries

@cindex join queries, building
@cindex join query, example
@cindex inner join queries, building
ORMLite supports basic @code{JOIN} SQL queries.  For more information about
how @code{JOIN} queries work see @uref{http://www.w3schools.com/Sql/sql_join.asp, JOIN documentation}.

You setup a join query by building 2 @code{QueryBuilder} objects -- one in the DAO from which you are returning objects,
and another DAO which is related to the first.  One of the objects must be a foreign field of the other object (either
direction is supported) or the join methods will throw an exception. 

For example, let's say you want to return a set of @code{Account} objects what have an @code{Order} that is larger than
$100.  We would set it up something like the following:

@example
QueryBuilder<Order, Integer> orderQb = orderDao.queryBuilder();
orderQb.where().ge("amount", 100.0F);
QueryBuilder<Account, Integer> accountQb = accountDao.queryBuilder();
// join with the order query
List<Account> results = accountQb.join(orderQb).query();
@end example

This will return all of the @code{Account} records that have a corresponding @code{Order} that has a @code{value} field
that is more than @code{100.0}.  Notice that none of the @code{Order} information is returned by the query -- just
@code{Account} information is retrieved.  You could also reverse the situation and, for example, return all of the orders
that have an account whose first-name is equal to @code{"Bob"}.  To compare fields from different tables, you can use the
@code{ColumnArg} class. @xref{Column Arguments}. 

ORMlite also supports the concept of @code{"LEFT JOIN"} which means, in the context of the above example, that accounts that
have @emph{no} orders will also be returned.  Typically with a "normal" join, only accounts that have orders are candidates to
be returned by the query.  ORMLite does @emph{not} support @code{"RIGHT JOIN"} or @code{"FULL JOIN"} since none of the "right"
object's information is being returned by the query. 

@emph{Please note} that other ORM libraries use @code{JOIN} statements to retrieve results from multiple tables to fill in
foreign fields and foreign collections.  ORMLite does not support this feature.  You can only get results from one table using
it.

@c ----------------------------------------------------------------
@node Use With Android, Android Basics, Join Queries, Top
@chapter Using With Android

@cindex use with Android OS
@cindex Android OS support
@cindex droid support

@menu
* Android Basics::            How to use ORMLite on Android OS.
* Config Optimization::       Use a table config file to speed up startup.
* Android Logging::           How to log messages under Android.
* RuntimeExceptionDao::       Runtime versus SQL exceptions.
* Upgrading Schema::          How to upgrade your SQLite schema.
@end menu

@c ----------------------------------------------------------------
@node Android Basics, Config Optimization, Use With Android, Use With Android
@section Android Basics

@cindex Android basics
Because of the lack of official support for JDBC in Android OS, ORMLite makes direct calls to the Android database APIs
to access SQLite databases.  You should make sure that you have downloaded and are depending on the @code{ormlite-core.jar}
and @code{ormlite-android.jar} files, but @emph{not} the @code{ormlite-jdbc.jar} version.  Although a number of developers
are using the package in their projects, we continue to improve how ORMLite integrates with the Android classes.
Feedback on this would be welcome.

After you have read the getting started section (@pxref{Getting Started}), the following instructions should be
followed to help you get ORMLite working under Android OS.

@enumerate

@item You will need to create your own database helper class which should extend the @code{OrmLiteSqliteOpenHelper} 
class.  This class creates and upgrades the database when your application is installed and can also provide the DAO classes
used by your other classes.  Your helper class must implement the methods
@code{onCreate(SQLiteDatabase sqliteDatabase, ConnectionSource connectionSource)} and
@code{onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion)}.
@code{onCreate} creates the database when your app is first installed while @code{onUpgrade} handles the upgrading
of the database tables when you upgrade your app to a new version.  There is a sample @code{DatabaseHelper} class as well as
@uref{http://ormlite.com/android/examples/, example projects online}. 

@item The helper can be kept open across all activities in your app with the same SQLite database connection reused by
all threads.  If you open multiple connections to the same database, stale data and unexpected results may occur.
We recommend using the @code{OpenHelperManager} to monitor the usage of the helper -- it will create it on the first
access, track each time a part of your code is using it, and then it will close the last time the helper is released.

@item  Once you have defined your database helper and are managing it correctly, you will need to use it in your @code{Activity}
classes.  An easy way to use the @code{OpenHelperManager} is to extend @code{OrmLiteBaseActivity} for each of your
activity classes -- there is also @code{OrmLiteBaseListActivity}, @code{OrmLiteBaseService}, and @code{OrmLiteBaseTabActivity}.
These classes provide a @code{helper} protected field and a @code{getHelper()} method to access the database helper whenever it
is needed and will automatically create the helper in the @code{onCreate()} method and release it in the @code{onDestroy()}
method.  See the sample @code{HelloAndroid} activity class in the examples.  @xref{Android Examples}.

@item If you do not want to extend the @code{OrmLiteBaseActivity} and other base classes then you will need to duplicate their
functionality.  You will need to call @code{OpenHelperManager.getHelper(Context context, Class openHelperClass)} at the start of
your code, save the helper and use it as much as you want, and then call @code{OpenHelperManager.release()} when you are done with
it.  You will probably want to have something like the following in your classes:

@example
private DatabaseHelper databaseHelper = null;

@@Override
protected void onDestroy() @{
    super.onDestroy();
    if (databaseHelper != null) @{
        OpenHelperManager.releaseHelper();
        databaseHelper = null;
    @}
@}

private DBHelper getHelper() @{
    if (databaseHelper == null) @{
        databaseHelper =
            OpenHelperManager.getHelper(this, DatabaseHelper.class);
    @}
    return databaseHelper;
@}
@end example

@cindex Android strings resources
@cindex database open helper wiring
@anchor{database open helper wiring}
@item By default, if you are using @code{OrmLiteBaseActivity} or other base classes, the @code{OpenHelperManager} will detect the
database helper class through reflection.  Another way to wire in the appropriate database helper class is to set the full class
name of it in the the @code{open_helper_classname} value defined in the @code{res/values/strings.xml} resource file .  You can also
set the class using the @code{OpenHelperManager.setOpenHelperClass(Class)} method in a @code{static @{@}} block in your code.

@item The Android native SQLite database type is @code{SqliteAndroidDatabaseType} and is used by the base classes internally.

@item @emph{WARNING:} You must make sure that any background threads call the @emph{OpenHelperManager.getHelper()} and
@emph{release()} methods appropriately.  Otherwise, if they access the database before it is opened or after it is closed, you will
get exceptions.

@end enumerate

Please see the example code documentation for more information.  @xref{Android Examples}.  Again, feedback on this is welcome.

@c ----------------------------------------------------------------
@node Config Optimization, Android Logging, Android Basics, Use With Android
@section Using Table Config File

@cindex garbage collection
@cindex startup optimization
@cindex table config file
@cindex database config file
@cindex config file for tables
@cindex android performance
For some time we have been struggling with DAO startup issues under Android that we thought were due to ORMLite object bandwidth.
Although improvements and DAO caching has been made, creating a couple of DAOs when your application starts can still take too long and
generate far too much garbage collection activity.  Turns out that one of the major culprits is some ugly code down in the Android OS --
especially in @code{Method.equals()}.  Because annotations use this method, looking up annotation values is @emph{extremely} expensive,
often garbage collecting thousands of objects and megabytes of space.  Android knows about the issues and a fix has been made but we have
no idea when these performance improvements will make it into an Android release.

With a little bit of work (and some caveats), you can remove all annotation work from your application and make DAO creation
an extremely fast operation.  ORMLite supports the loading of the data configurations from a text configuration file.
When a DAO is created, these configurations will be used, removing the need for any annotation method calls entirely.

@enumerate

@item The @code{OrmLiteConfigUtil} utility class writes a @code{ormlite_config.txt} configuration file in the raw resource
folder @code{res/raw/ormlite_config.txt}.  You will need to extend this class into your own project along side your @code{DatabaseHelper}
class.  It should look something like:

@example
public class DatabaseConfigUtil extends OrmLiteConfigUtil @{
  public static void main(String[] args) throws Exception @{
    writeConfigFile("ormlite_config.txt");
  @}
@}
@end example

@item You will need to run this utility locally on your development box (not in an Android device), whenever you make a change to one of
your data classes.  This means that right now, this @emph{must} be done by hand to keep the configuration file in sync with your database
classes.  To run the utility you will need to use the local Java runtime environment (JRE).  Under eclipse, edit the "Run Configuration" for
the utility, select the JRE tab, and select an alternative JRE (1.5 or 1.6).  Your project's JRE should be undefined since it is an Android
application.  You'll also need to remove the Android bootstrap entry from the Classpath tab.

@item By default this utility will look in the current directory and below in files ending in @code{.java} for the existence of one of the
@code{@@DatabaseTable} or @code{DatabaseField} annotations.  These classes will be investigated and written into the database configuration
file.  You can also list the classes to be processed:

@example
public class DatabaseConfigUtil extends OrmLiteConfigUtil @{
  private static final Class<?>[] classes = new Class[] @{
    SimpleData.class,
  @};
  public static void main(String[] args) throws Exception @{
    writeConfigFile("ormlite_config.txt", classes);
  @}
@}
@end example

@item When the utility is run it should create the @code{ormlite_config.txt} configuration file in the raw resource folder.  This folder must
exist before the utility is run.  Afterwards, if you refresh your project your should see the file appear.  In the Eclipse console, you
should see something like the following outputted by the utility:

@example
Writing configurations to /HelloAndroid/./res/raw/ormlite_config.txt
Wrote config for class com.example.helloandroid.SimpleData
Done.
@end example

The config file generated should look something like:

@example
#
# generated on 2020/09/15 01:42:02
#
# --table-start--
dataClass=com.example.helloandroid.SimpleData
tableName=simpledata
# --table-fields-start--
# --field-start--
fieldName=id
canBeNull=true
generatedId=true
@dots{}
@end example

@item The first time you create the config file in the resource folder, the Android build plugin should add it to the @code{R.java} file inside of
the @code{gen} folder.  This defines a unique integer value so that the application can open this resource by file-id number.  The file should contain
something like:

@example
public final class R @{
  @dots{}
  public static final class raw @{
    public static final int ormlite_config=0x7f040000;
  @}
  @dots{}
@}
@end example 

@item After the @code{R.java} file entry has been generated, you will need to enable the reading of the file at runtime.  Inside of your @code{DatabaseHelper}
class, you will need to change the constructor to add the integer file-id.  The constructor will look something like the following:

@example
public DatabaseHelper(Context context) @{
  super(context, DATABASE_NAME, null, DATABASE_VERSION,
    R.raw.ormlite_config);
@}
@end example

Notice the @code{R.raw.ormlite_config} entry at the end that passes the file-id to the super class so it can be read in.
You can also pass in a file-name or a Java @code{File} if you want to load in the config file from another location.

@item When you build and run your application, you will know that the database configuration file is being loaded if you
see log entries like the following:

@example
I/DaoManager(  999): Loaded configuration for class ...SimpleData
@end example

Oh, and if it is working you should notice a significant lack of GC messages during DAO startup.

@end enumerate

As of 9/2011, this is one of the newest parts of ORMLite so we most likely will be improving it.  Feedback is welcome.

@c ----------------------------------------------------------------
@node Android Logging, RuntimeExceptionDao, Config Optimization, Use With Android
@section Android Logging

@cindex Android logging
@cindex logging under Android
@anchor{Android logging}

The @code{ormlite-android.jar} classes define the @code{AndroidLog} class which is the Android specific version of ORMLite
logging.  This class makes calls to the @code{Log.d}, @code{Log.i}, @dots{} methods in the Android API.  To see the log output,
you will need to use the @code{adb} utility to view the log output:

@example
adb logcat
@end example

Since @code{INFO} is the default under Android, only message such as the following will be spit out by default:

@example
I/TableUtils(  254): creating table 'simpledata'
I/TableUtils(  254): creating index 'simpledata_string_idx' for table
   'simpledata
I/TableUtils(  254): executed create table statement changed 1 rows:
   CREATE TABLE `simpledata` (`date` VARCHAR, `id` INTEGER PRIMARY
   KEY AUTOINCREMENT , `even` SMALLINT )
I/TableUtils(  254): executed create table statement changed 1 rows:
   CREATE INDEX `simpledata_string_idx` ON `simpledata` ( `string` )
@end example

To enable more debug information you will want to do something like the following to turn on logging for a particular class:

@example
adb shell setprop log.tag.StatementExecutor VERBOSE
adb shell setprop log.tag.BaseMappedStatement VERBOSE
adb shell setprop log.tag.MappedCreate VERBOSE
@end example

This enables messages such as:

@example
D/BaseMappedStatement(465): create object using 'INSERT INTO `simpledata`
   (`date` ,`string` ,`millis` ,`even` ) VALUES (?,?,?,?)' and 4 args,
   changed 1 rows
D/BaseMappedStatement(465): assigned id '9' from keyholder to 'id' in
   SimpleData object
@end example

To enable all debug messages for all ORMLite classes then use the following:

@example
adb shell setprop log.tag.ORMLite DEBUG
@end example

@emph{NOTE:} Unfortunately, Android property names are limited in size so the ORMLite logger only takes that last 23 [sic]
characters of the class name if it is larger than 23 characters. For example, if the class is AndroidDatabaseConnection
you would do:

@example
adb shell setprop log.tag.droidDatabaseConnection VERBOSE
@end example

If you are trying to track operations performed to the database by ORMLite use:

@example
adb shell setprop log.tag.droidDatabaseConnection VERBOSE
adb shell setprop log.tag.ndroidCompiledStatement VERBOSE
@end example

@c ----------------------------------------------------------------
@node RuntimeExceptionDao, Upgrading Schema, Android Logging, Use With Android
@section Runtime Versus SQL Exceptions

@cindex RuntimeExceptionDao
@cindex SQLExceptionDao
@cindex exceptions, runtime
By default, most of the DAO methods throw @code{SQLException} which is the default internal exception for most JDBC and other
SQL calls.  But in Android-land, especially, most of the exceptions extend @code{RuntimeException} so having to put a lot of 
ignored @code{try ... catch} stanzas is inconvenient.  For this reason we've added a @code{RuntimeExceptionDao} which wraps all
calls to the underlying DAO to rethrow the SQL exceptions as runtime exceptions.  To get one, you can wrap your own down in it:

@example
Dao<Account, String> dao =
  DaoManager.createDao(connectionSource, Account.class);
RuntimeExceptionDao<Account, String> accountDao =
  new RuntimeExceptionDao<Account, String>(dao);
@end example

Or you can call the @code{createDao} helper methods on @code{RuntimeExceptionDao}:

@example
RuntimeExceptionDao<Account, String> accountDao =
  RuntimeExceptionDao.createDao(connectionSource, Account.class);
@end example

Other classes such as @code{TableUtils} and @code{QueryBuilder} still throw @code{SQLException} but the hope is that
@code{RuntimeExceptionDao} helps a little bit at least.

@c ----------------------------------------------------------------
@node Upgrading Schema, Advanced, RuntimeExceptionDao, Use With Android
@section Upgrading Your Schema

@cindex updating database schema
@cindex upgrading database schema
@cindex schema upgrade
@cindex database schema upgrade
When you upgrade your application, you may have to add columns or make other changes to the data that was stored by previous
versions of your application.  If you are on Android then in your @code{DatabaseHelper}, there should be an @code{onUpgrade()} method
that extends the following method from the @code{OrmLiteSqliteOpenHelper}.

@example
abstract void onUpgrade(SQLiteDatabase database,
  ConnectionSource connectionSource, int oldVersion, int newVersion)
@end example 

In that method you can use your DAO to perform any tweaks to the schema:

@example
Dao<Account, Integer> dao = getHelper().getAccountDao();
// change the table to add a new column named "age" 
dao.executeRaw("ALTER TABLE `account` ADD COLUMN age INTEGER;");
@end example

@cindex sqlite alter table
Here's more information about @uref{http://www.sqlite.org/lang_altertable.html, SQLite's ALTER TABLE}.
In SQLite, all you can do is rename a table name and add a new column.  You can't rename or remove a column or change the constraints.
Remember that SQLite is typeless so changing the type of a column doesn't matter.

Most likely, you should make your schema changes conditional to the version you are upgrading from:

@example
if (oldVersion < 2) @{
  // we added the age column in version 2
  dao.executeRaw("ALTER TABLE `account` ADD COLUMN age INTEGER;");
@}
if (oldVersion < 3) @{
  // we added the weight column in version 3
  dao.executeRaw("ALTER TABLE `account` ADD COLUMN weight INTEGER;");
@}
@end example

You can also modify data in the tables using something like the following:

@example
dao.executeRaw(
    "ALTER TABLE `account` ADD COLUMN hasDog BOOLEAN DEFAULT 0;");
dao.updateRaw("UPDATE `account` SET hasDog = 1 WHERE dogCount > 0;");
@end example

If you are using some other database over JDBC then the above commands will work but you will have to handle the versioning of your application
manually.

@c ----------------------------------------------------------------
@node Advanced, Spring Configuration, Upgrading Schema, Top
@chapter Advanced Concepts

@menu
* Spring Configuration::       How to wire ORMLite in Spring.
* Class Configuration::        Alternate ways to configure your classes.
* Database Type Details::      Description of the database specific code.
* DAO Methods::                What functionality is provided by the DAO.
* Logging::                    How to log messages with ORMLite.
* Dependencies::               External dependencies of ORMLite.
* Transactions::               Using database transactions.
* Object Caches::              How to cache objects handled by ORMLite.
* Maven::                      Configure a maven project for ORMLite.
* Batch Operations::           Running batch operations.
* Custom Persisters::          Defining custom data type persisters.
@end menu

@c ----------------------------------------------------------------
@node Spring Configuration, Class Configuration, Advanced, Advanced
@section Spring Configuration

@cindex spring framework, using with
@cindex using spring framework
@cindex configuration with Spring
ORMLite contains some classes which make it easy to configure the various database classes using
the @uref{http://www.springsource.org/, Spring Framework}.

@table @code

@cindex TableCreator
@cindex create schema
@cindex create tables
@cindex generation of the schema
@cindex schema generation
@cindex auto create tables
@cindex auto drop tables
@cindex drop tables
@item TableCreator

Spring bean that auto-creates any tables that it finds DAOs for if the system property @code{ormlite.auto.create.tables}
has been set to true. It will also auto-drop any tables that were auto-created if the property
@code{ormlite.auto.drop.tables} has been set to true.  This should be used carefully and probably only in tests.

@cindex dao factory
@item DaoFactory

Spring bean that can be used to create Dao's for certain classes without needing to define their own Dao class.

@end table

@cindex spring examples
Here's an example of a full Spring configuration.

@example
<!-- URL used for database, probably should be in properties file -->
<bean id="databaseUrl" class="java.lang.String">
    <!-- we are using the in-memory H2 database in this example -->
    <constructor-arg index="0" value="jdbc:h2:mem:account" />
</bean>

<!-- datasource used by ORMLite to connect to the database -->
<bean id="connectionSource"
    class="com.j256.ormlite.jdbc.JdbcConnectionSource"
    init-method="initialize">
    <property name="url" ref="databaseUrl" />
    <!-- probably should use system properties for these too -->
    <property name="username" value="foo" />
    <property name="password" value="bar" />
</bean>

<!-- abstract dao that is common to all defined daos -->
<bean id="baseDao" abstract="true" init-method="initialize">
    <property name="connectionSource" ref="connectionSource" />
</bean>

<!-- our daos -->
<bean id="accountDao"
    class="com.j256.ormlite.examples.common.AccountDaoImpl"
    parent="baseDao" />
<bean id="deliveryDao" class="com.j256.ormlite.spring.DaoFactory"
  factory-method="createDao">
    <constructor-arg index="0" ref="connectionSource" />
    <constructor-arg index="1"
      value="com.j256.ormlite.examples.spring.Delivery" />
</bean>
@end example

You can also take a look at the spring example code.  @xref{spring example}.

@c ----------------------------------------------------------------
@node Class Configuration, Database Type Details, Spring Configuration, Advanced
@section Class Configuration

@cindex class configuration
The simplest mechanism for configuring a class to be persisted by ORMLite is to use the @code{@@DatabaseTable}
and @code{@@DatabaseField} annotations.  @xref{Local Annotations}.  However if you do not own the class you are
persisting or there are permission problems with the class, you may want to configure the class using Java code instead.

@cindex configure a class in code
To configure a class in code, you use the @code{DatabaseFieldConfig} and @code{DatabaseTableConfig} objects.
The field config object holds all of the details that are in the @code{@@DatabaseField} annotation as well as
the name of the corresponding field in the object.  The @code{DatabaseTableConfig} object holds the class and the
corresponding list of @code{DatabaseFieldConfig}s.  For example, to configure the @code{Account} object using Java code
you'd do something like the following:

@example
List<DatabaseFieldConfig> fieldConfigs =
    new ArrayList<DatabaseFieldConfig>();
DatabaseFieldConfig field1 = new DatabaseFieldConfig("name");
field1.setId(true);
fieldConfigs.add(field1);
DatabaseFieldConfig field2 = new DatabaseFieldConfig("password");
field2.setCanBeNull(false);
fieldConfigs.add(field2);
DatabaseTableConfig<Account> accountTableConfig
    = new DatabaseTableConfig<Account>(Account.class, fieldConfigs);

AccountDaoImpl accountDao =
    new AccountDaoImpl(connectionSource, accountTableConfig);
@end example

@cindex spring wire a class
See the Javadocs for the @code{DatabaseFieldConfig} class for the fields to pass to the constructor.  You can also
use the no-argument constructor and call the setters for each field.  You use the setters as well when you are
configuring a class using Spring wiring.  Here is the above example in Spring:

@example
<bean id="accountTableConfig"
  class="com.j256.ormlite.table.DatabaseTableConfig">
    <property name="dataClass"
        value="com.j256.ormlite.examples.common.Account" />
    <property name="tableName" value="account" />
    <property name="fieldConfigs">
        <list>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="name" />
                <property name="id" value="true" />
            </bean>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="password" />
                <property name="canBeNull" value="false" />
            </bean>
        </list>
    </property>
</bean>
@end example

You can also look at the field configuration example code.  @xref{field config example}.

@c ----------------------------------------------------------------
@node Database Type Details, DAO Methods, Class Configuration, Advanced
@section Database Specific Code

@cindex database type
@cindex database specific code
ORMLite uses an internal @code{DatabaseType} object which defines all of the per-database information necessary
to support the various features on all of the different database types.  The @code{JdbcConnectionSource} uses the database
URL to pick the correct @code{DatabaseType}.  If it picks an incorrect one then you may need to set the @code{DatabaseType}
on the connection source @emph{directly}.  For example:

@example
String databaseUrl = "jdbc:derby://dbserver1:1527/";
DatabaseType databaseType = new DerbyClientServerDatabaseType();
ConnectionSource connectionSource =
   new JdbcConnectionSource(databaseUrl, databaseType);
@end example

Android users do not need to worry about this because the @code{AndroidConnectionSource} always uses the
@code{SqliteAndroidDatabaseType}.  @xref{Use With Android}.

The @code{DatabaseType} classes are found in @code{com.j256.ormlite.db}.  Each of the supported databases has a class there
which implements the code needed to handle the unique features of the database (H2DatabaseType, MySqlDatabaseType, etc.).
If you want to help develop and test against other SQL databases, a externally available server that the author could connect
to and test against would be appreciated.  Please contact the author if your database is not supported or if you want to help.

The following methods are currently used by the system to isolate the database specific behavior in one place.
See the javadocs for the @code{DatabaseType} class for the most up to date information.

@table @code

@item isDatabaseUrlThisType

Return true if the database URL corresponds to this database type. Usually the URL is in the form @code{jdbc:ddd:@dots{}}
where ddd is the driver url part.

@item loadDriver

Load the driver class associated with this database so it can wire itself into JDBC.

@item appendColumnArg

Takes a field type and appends the SQL necessary to create the field.  It may also generate arguments
for the end of the table create statement or commands that must run before or after the table create.

@item dropColumnArg

Takes a field type and adds all of the commands necessary to drop the column from the database.

@item appendEscapedEntityName

Add a entity-name (table or column name) word to the SQL wrapped in the proper characters to escape it.
This avoids problems with table, column, and sequence-names being reserved words.

@item appendEscapedWord

Add the word to the string builder wrapped in the proper characters to escape it. This avoids problems with
data values being reserved words.

@item generateIdSequenceName

Return the name of an ID sequence based on the table-name and the field-type of the id.  This is required
by some database types when we have generated ids.

@item getCommentLinePrefix

Return the prefix to put at the front of a SQL line to mark it as a comment.

@item isIdSequenceNeeded

Return true if the database needs a sequence when you insert for generated IDs.  Some databases handle
generated ids internally.

@item getFieldConverter

Return the field converter associated with a particular field type.  This allows the database instance to
convert a field as necessary before it goes to the database.

@item isVarcharFieldWidthSupported

Return true if the database supports the width parameter on VARCHAR fields.

@item isLimitSqlSupported

Return true if the database supports the LIMIT sql command.

@item isLimitAfterSelect

Return true if the LIMIT should be called after SELECT otherwise at the end of the WHERE (the default).

@item appendLimitValue

Add the necessary SQL to limit the results to a certain number.

@item isOffsetSqlSupported

Return true if the database supports the OFFSET SQL command in some form.

@item isOffsetLimitArgument 

Return true if the database supports the offset as a comma argument from the limit. This also means that the
limit @emph{must} be specified if the offset is specified.

@item appendOffsetValue

Append to the string builder the necessary SQL to start the results at a certain row number.

@item appendSelectNextValFromSequence

Add the SQL necessary to get the next-value from a sequence. This is only necessary if
isIdSequenceNeeded returns true.

@item appendCreateTableSuffix

Append the SQL necessary to properly finish a CREATE TABLE line.

@item isCreateTableReturnsZero

Returns true if a 'CREATE TABLE' statement should return 0. False if > 0.

@item isEntityNamesMustBeUpCase

Returns true if table and field names should be made uppercase.  This is an unfortunate "feature" of Derby and Hsqldb.
See the Javadocs for the class for more information.

@item isNestedSavePointsSupported

Returns true if the database supports nested savepoints (transactions).

@item getPingStatement

Return an statement that doesn't do anything but which can be used to ping the database by sending it over a
database connection.

@item isBatchUseTransaction

Returns true if batch operations should be done inside of a transaction. Default is false in which case
auto-commit disabling will be done.

@item isTruncateSupported

Returns true if the table truncate operation is supported.

@item isCreateIfNotExistsSupported

Returns true if the table creation @code{IF NOT EXISTS} syntax is supported.

@end table

@c ----------------------------------------------------------------
@node DAO Methods, Logging, Database Type Details, Advanced
@section DAO Methods

@cindex dao methods
The DAO classes provide the following methods that you can use to store your objects to your database.
This list may be out of date.  See the @code{Dao} interface class for the latest methods.

@table @code

@cindex query for id
@item queryForId(ID id)

Looks up the id in the database and retrieves an object associated with it.

@cindex query for first
@item queryForFirst(PreparedQuery<T> preparedQuery)

Query for and return the first item in the object table which matches a prepared statement. This can be used to return
the object that matches a single unique column.  You should use queryForId if you want to query for the id column.

@cindex query for all
@item queryForAll()

Query for all of the items in the object table and return a list of them. For medium sized or large tables,
this may load a lot of objects into memory so you should consider using the @code{iterator} method instead.

@cindex queryForEq
@cindex query for single value
@item queryForEq(String fieldName, Object value)

Query for the items in the object table that match a simple where with a single @code{field = value} type of WHERE clause.  This
is a convenience method for calling @code{queryBuilder().where().eq(fieldName, value).query()}.

@cindex queryForMatching
@cindex query for matching object
@cindex matching object
@item queryForMatching(T matchObj)

Query for the rows in the database that match the object passed in as an argument. Any fields in the matching object that
are not the default value (null, false, 0, 0.0, etc.) are used as the matching parameters with @code{AND}.  If you are worried
about SQL quote escaping, you should use @code{queryForMatchingArgs}.

@cindex queryForMatchingArgs
@cindex query for matching object
@cindex matching object
@item queryForMatchingArgs(T matchObj)

Same as @code{queryForMatching} but this uses SQL ? arguments. This is slightly more expensive but you don't have to worry about
SQL quote escaping.

@cindex queryForFieldValues
@cindex query for field value map
@item queryForFieldValues(Map<String, Object> fieldValues)

Query for the rows in the database that matches all of the field to value entries from the map passed in.

@cindex queryForFieldValuesArgs
@item queryForFieldValuesArgs(Map<String, Object> fieldValues)

Same as @code{queryForFieldValues} but this uses SQL ? arguments. This is slightly more expensive but you don't have to worry
about SQL quote escaping.

@cindex queryForSameId
@item queryForSameId(T data)

Query for a data item in the table that has the same ID as the data parameter.

@cindex query builder
@cindex statement builder
@item queryBuilder()

Create and return a new @code{QueryBuilder} object which allows you to build a custom query.  @xref{QueryBuilder Basics}.

@cindex update builder
@item updateBuilder()

Create and return a new @code{UpdateBuilder} object which allows you to build a custom update statement.  @xref{UpdateBuilder}.

@cindex delete builder
@item deleteBuilder()

Create and return a new @code{DeleteBuilder} object which allows you to build a custom delete statement.  @xref{DeleteBuilder}.

@cindex query for objects
@item query(PreparedQuery<T> preparedQuery)

Query for the items in the object table which match a prepared statement.  @xref{Statement Builder}.  This returns a
list of matching objects. For medium sized or large tables, this may load a lot of objects into memory so you
should consider using the @code{iterator} method instead.  

@cindex creating an object
@item create(T data)

Create a new entry in the database from an object.  Should return 1 indicating 1 row was inserted.

@cindex create if not exists
@item createIfNotExists(T data)

This is a convenience method to creating a data item but only if the ID does not already exist in the table. This extracts the id from
the data parameter, does a query for on it, returning the data if it exists.  If it does not exist then create is called with the data
parameter.

@cindex create or update
@item createOrUpdate(T data)

This is a convenience method for creating an item in the database if it does not exist. The id is extracted from
the data argument and a query-by-id is made on the database. If a row in the database with the same id exists
then all of the columns in the database will be updated from the fields in the data parameter. If the id is @code{null}
(or 0 or some other default value) or doesn't exist in the database then the object will be created in the
database. This also means that your data item @emph{must} have an id field defined.

@cindex updating an object
@item update(T data)

Save the fields from an object to the database. If you have made changes to an object, this is how you persist
those changes to the database. You cannot use this method to update the id field -- see @code{updateId()}.  This
should return 1 since 1 row was updated.

@cindex update an object id
@anchor{updateId}
@item updateId(T data, ID newId)

Update an object in the database to change its id to a new id. The data @emph{must} have its current id set and
the new-id is passed in as an argument.  After the id has been updated in the database, the id field of the data
object will also be changed.  This should return 1 since 1 row was updated.

@cindex update custom statement
@cindex custom update statement
@item update(PreparedUpdate<T> preparedUpdate)

Update objects that match a custom update statement.

@cindex refreshing an object
@item refresh(T data, ID newId)

Does a query for the object's id and copies in each of the field values from the database to refresh the data
parameter. Any local object changes to persisted fields will be overwritten.  If the database has been updated
this brings your local object up-to-date.  This should return 1 since 1 row was retrieved.

@cindex deleting an object
@item delete(T data)

Delete an object from the database.  This should return 1 since 1 row was removed.

@cindex deleting by ID
@item deleteById(ID id)

Delete an object from the database if you have its id.  This should return 1 since 1 row was removed.

@cindex delete multiple objects
@item delete(Collection<T> datas)

Delete a collection of objects from the database using an IN SQL clause.  This returns the number of rows that
were deleted.

@cindex delete objects by id
@item deleteIds(Collection<ID> ids)

Delete the objects that match the collection of ids from the database using an IN SQL clause.   This returns the
number of rows that were deleted.  

@cindex delete custom statement
@cindex custom delete statement
@item delete(PreparedDelete<T> preparedDelete)

Delete objects that match a custom delete statement.

@cindex iterator
@item iterator()

This method satisfies the @code{Iterable} Java interface for the class and allows you to iterate through the objects
in the table using SQL.  This method allows you to do something like:

@example
for (Account account : accountDao) @{ @dots{} @}
@end example

@emph{WARNING:} See the @code{Dao} class for warnings about using this method.

@item iterator(PreparedQuery<T> preparedQuery)

Same is the @code{iterator} method but with a prepared statement parameter. @xref{Statement Builder}.

@cindex wrapped iterable
@cindex CloseableWrappedIterable
@item getWrappedIterable()

This returns a one time use iterable class that can be closed afterwards. The DAO itself is
@code{CloseableWrappedIterable} but multiple threads can each call this to get their own closeable iterable.
This allows you to do something like:

@example
CloseableWrappedIterable<Account> wrappedIterable =
    accountDao.getWrappedIterable();
try @{
    for (Account account : wrappedIterable) @{
        @dots{}
    @}
@} finally @{
    wrappedIterable.close();
@}
@end example

@item getWrappedIterable(PreparedQuery<T> preparedQuery)

Same as @code{getWrappedIterable()} but with a prepared query parameter.

@cindex close last iterator
@item closeLastIterator()

This closes the last iterator returned by the @code{iterator()} method.

@emph{NOTE:} This is not reentrant. If multiple threads are getting iterators from this DAO then you should use
@code{getWrappedIterable()} method.

@cindex query for all raw
@cindex raw select statements
@cindex executing raw select statements
@item queryRaw(String query, String... arguments)

Query for all of the items in the object table that match the SQL select query argument. This method allows you
to do special queries that aren't supported otherwise. For medium sized or large tables, this may load a lot of 
objects into memory so you should consider using the @code{iterator()} method on the @code{GenericRawResults}
instead of the @code{getResults} method.  @xref{Raw Queries}.

@item queryRaw(String query, RawRowMapper<UO> mapper, String... arguments)

Same as the above @code{queryRaw} method but with the addition of a row mapper.  Instead of each row being returned
as an array of strings, this will map the row using the mapper object passed in.  @xref{Raw Queries}.

@item queryRaw(String query, DataType[] columnTypes, RawRowObjectMapper<UO> mapper, String... arguments)

Similar to the above @code{queryRaw} but uses the column-types array to present an array of object results to the mapper
instead of strings. The arguments are optional but can be set with strings to expand @code{?} type of SQL.  @xref{Raw Queries}.

@item queryRaw(String query, DataType[] columnTypes)

Same as the above @code{queryRaw} method but with the addition of a an array of column data types.  Instead of each
row being returned as an array of strings, they are returned as an array of objects.  @xref{Raw Queries}.

@item queryRawValue(String query, String... arguments)

Perform a raw query that returns a single value (usually an aggregate function like @code{MAX} or @code{COUNT}). If the query
does not return a single long value then it will throw a SQLException.

@item executeRaw(String statement)

Run a raw execute SQL statement against the database.  @xref{Raw Executes}.

@item updateRaw(String statement)

Run a raw update SQL statement (@code{INSERT}, @code{DELETE}, or @code{UPDATE} against the database.
@xref{Raw Updates}.

@cindex batch operations
@cindex callBatchTasks
@anchor{callBatchTasks}
@item callBatchTasks(Callable callable)

Call the call-able that will perform a number of batch tasks. This is for performance when you want to run a
number of database operations at once -- maybe loading data from a file. This will turn off what databases call
"auto-commit" mode, run the call-able and then re-enable "auto-commit".  If auto-commit is not supported then it
will try to use a database transaction to speed up the tasks.

@emph{NOTE:} If neither auto-commit nor transactions are supported by the database type then this method may not
give any performance improvement.

@example
accountDao.callBatchTasks(new Callable<Void>() @{
    public Void call() throws SQLException @{
        // insert a number of accounts at once
        for (Account account : accountsToInsert) @{
           // update our account object
           accountDao.create(account);
        @}
        return null;
    @}
@});
@end example

@cindex count of table rows
@cindex countOf
@item countOf()

Returns the value returned from a @code{SELECT COUNT(*)} query which is the number of rows in the table.  Depending on the
database and the size of the table, this could be expensive. 

@item countOf(PreparedQuery<T> preparedQuery)

Returns the number of rows in the table associated with the prepared query passed in. Depending on the size of
the table and the database type, this may be expensive and take a while.

@cindex empty foreign collection
@cindex foreign collection, empty
@cindex assignEmptyForeignCollection
@item assignEmptyForeignCollection(T parent, String fieldName)

Assigns an empty collection to the appropriate collection field that has the field-name. This allows you to add things to the
collection from the start.  This allows you to do something like:

@example
accoundDao.assignEmptyForeignCollection(account, "orders");
// this would add it the collection and the internal DAO
account.orders.add(order1);
@end example

@cindex enable object cache
@cindex object cache, enable
@item setObjectCache(boolean enabled);

Call this with true to enable an object cache for the DAO. Set to false to disable any caching.  @xref{Object Caches}.

@item setObjectCache(ObjectCache objectCache);

Same as @code{setObjectCache(boolean)} except you specify the actual cache instance to use for the DAO.  This allows
you to inject your own cache classes.  Call it with null to disable the cache.  @xref{Object Caches}.

@cindex clear object cache
@cindex object cache, clear
@item clearObjectCache();

Flush the object cache if it has been enabled. This will remove an objects that are in the cache to reclaim
memory. Any future queries will re-request them from the database.

@cindex map select starquery
@cindex object mapping for select star
@cindex row mapping for select star
@item mapSelectStarRow(DatabaseResults results)

Return the latest row from the database results from a query to @code{select *} (star).  This allows you to remap the
results.  It is particularly useful if you are repositioning a database cursor externally. 

@item getSelectStarRowMapper()

Return a row mapper that is suitable for mapping results from a query to @code{select *} (star).

@cindex if id exists
@cindex does id exist already
@item idExists(ID id)

Returns true if an object exists that matches this ID otherwise false.

@cindex cache database connection
@item startThreadConnection()

@emph{WARNING:} This method is for advanced users only. It is only to support the @code{setAutoCommit(conn, boolean)}
and other methods below. Chances are you should be using the @code{TransactionManager} class' @code{callInTransaction(Callable)}
method instead f this method unless you know what you are doing.

This allocates a connection for this specific thread that will be used in all other DAO operations. The thread
@emph{must} call @code{endThreadConnection(conn)} once it is done with the connection. It is highly recommended that a
@code{try / finally} pattern be used here to ensure you do not leak connections.

This is really only useful if you are using a pooled connection source and want to do certain operations on the
same pool. Android users, for example have a single connection to the database so this is effectively a no-op.

@item endThreadConnection(DatabaseConnection connection)

This method is used to free the connection returned by the @code{startThreadConnection()} above.

@item setAutoCommit(DatabaseConnection connection, boolean autoCommit)

Set auto-commit mode to be true or false on the connection returned by the @code{startThreadConnection()}. This
may not be supported by all database types.

@item isAutoCommit(DatabaseConnection connection)

Return true if the database connection returned by the @code{startThreadConnection()} is in auto-commit mode
otherwise false. This may not be supported by all database types.

@item commit(DatabaseConnection connection)

If you have previously called @code{setAutoCommit(conn, false)} then this will commit all changes to the database
made from that point up to now on the connection returned by the @code{startThreadConnection()}. The changes
will be written to the database and discarded. The connection will continue to stay in the current auto-commit
mode.

@emph{WARNING:} Chances are you should be using the @code{TransactionManager} class' @code{callInTransaction(Callable)}
method instead unless you know what you are doing.

@item rollBack(DatabaseConnection connection)

If you have previously called @code{setAutoCommit(conn, false)} then this will roll-back and flush all changes to the
database made from that point up to now on the connection returned by the @code{startThreadConnection()}. None
of those changes will be written to the database and are discarded. The connection will continue to stay in the
current auto-commit mode.

@emph{WARNING:} Chances are you should be using the @code{TransactionManager} class' @code{callInTransaction(Callable)}
method instead unless you know what you are doing.

@end table

@c ----------------------------------------------------------------
@node Logging, Dependencies, DAO Methods, Advanced
@section ORMLite Logging

@cindex logging information
ORMLite uses a log system which can plug into Apache commons logging, Log4j, Android Log, or its own internal
log implementations.  The logger code first looks for the @code{android.util.Log} and if found will use the Android internal
logger.  Next it looks for @code{org.apache.commons.logging.LogFactory} class in the class-path -- if found it will use Apache
commons logging.  If that class is not found it then looks for @code{org.apache.log4j.Logger} and if found will use Log4j.
If none of these classes are available it will use an internal logger -- see @code{LocalLog}.  The logger code also provides
simple @{@} argument expansion like @code{slf4j} which means that you can save on @code{toString()} calls and
@code{StringBuilder} operations if the log level is not high enough.  This allows us to do something like the following:

@example
private static Logger logger =
  LoggerFactory.getLogger(QueryBuilder.class);
@dots{}
logger.debug("built statement @{@}", statement);
@end example

If you are using log4j (through Apache commons logging or directly), you can use something
like the following as your @code{log4j.properties} file to see details about the SQL calls.

@cindex log4j properties file
@example
log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout

# print the date in ISO 8601 format
log4j.appender.stdout.layout.ConversionPattern=%d@{ISO8601@} [%p] %c@{1@} %m%n

# be more verbose with our code
log4j.logger.com.j256.ormlite=DEBUG

# to enable logging of arguments to all of the SQL calls
# uncomment the following lines
#log4j.logger.com.j256.ormlite.stmt.mapped.BaseMappedStatement=TRACE
#log4j.logger.com.j256.ormlite.stmt.mapped.MappedCreate=TRACE
#log4j.logger.com.j256.ormlite.stmt.StatementExecutor=TRACE
@end example

@cindex logging sql arguments
@cindex sql argument logging
@emph{Notice} that you can uncomment the last lines in the above log4j.properties file to log the arguments to the
various SQL calls.  This may expose passwords or other sensitive information in the database so probably should
only be used during debugging and should not be the default.

If you are using the @code{LocalLog} logger (which is helpful for testing at least) then you can configure it using
a @code{ormliteLocalLog.properties} file.  The file configures the log output of the ORMLite LocalLog class.
Lines in the file have the format @code{class-regex-pattern = Level}.  For example:

@example
com\.j256\.ormlite.* = DEBUG
com\.j256\.ormlite\.stmt\.mapped\.BaseMappedStatement = TRACE
com\.j256\.ormlite\.stmt\.mapped\.MappedCreate = TRACE
com\.j256\.ormlite\.stmt\.StatementExecutor = TRACE
@end example

@emph{NOTE:} You should escape any period characters with a single backslash unless they are part of a regex match.

@cindex global log level
@cindex log messages, disable
@cindex filter log messages
@cindex disable all log messages
@cindex ignore all log messages
For all of the logging implementations, you can use the @code{Logger.setGlobalLogLevel(...)} method to filter all log
messages.  The argument you pass in filters out any messages to less important levels.  You should call that method
in the @code{main(...)} method or as early in your application as possible.

@example
// filter out TRACE messages only
Logger.setGlobalLogLevel(Level.DEBUG);
// only allow error or fatal messages
Logger.setGlobalLogLevel(Level.ERROR);
// turn off all log messages
Logger.setGlobalLogLevel(Level.OFF);
@end example

@cindex other loggers
@cindex logging, custom implemenations
@cindex null logging implementation
@cindex dev-null logging implementation
@cindex logging factory
You can also implement your own logging implementation by using the @code{LoggerFactory.setLogFactory(...)} method.
The the factory needs to implement a @code{Log createLog(String)} method and the @code{Log} class only has a couple
methods to test the log level and log messages with optional throwables.

You can use the @code{NullLogFactory} as another way to disable all log messages by sending them to @code{NullLog}
which ignores all log calls.

For logging with Android, @xref{Android Logging}.  

@c ----------------------------------------------------------------
@node Dependencies, Transactions, Logging, Advanced
@section External Dependencies

@cindex external dependencies
ORMLite does not have any direct dependencies.  It has logging classes that depend on Apache commons-logging
and Log4j but these classes will @emph{not} be referenced unless they exist in the class-path.
  
If you want to get the ORMLite Junit tests to run, there are test dependencies on the following packages:

@table @code

@cindex JPA
@item javax.persistence

For testing the compatibility annotations @code{@@Column} and the like.

@item org.junit

We use Junit for our unit tasks.

@item org.easymock.easymock

We use, and are in love with, @uref{http://easymock.org/, EasyMock}.  It allows us to mock out dependencies so we can
concentrate on testing a particular class instead of the whole package. 

@item com.h2database

As a test database implementation, H2 is very fast and simple to use.  However, we recommend MySQL or Postgres for
multi-threaded, high-performance, production databases.

@end table

@c ----------------------------------------------------------------
@node Transactions, Object Caches, Dependencies, Advanced
@section Using Database Transactions

@cindex database transactions
@cindex transactions
@cindex commit
@cindex roll back
Database transactions allow you to make a number of changes to the database and then if any of them fail, none of the
changes are actually written.  For example, let's say you are recording an order into your order entry system which
requires you to insert a row into the Order table and also to update the Account table with the order number.  If the
Order was inserted but then a disk error stopped the Account from being updated, the Order data would be left dangling.
If you used a transaction then both changes would be saved to the database only when the transaction was closed.  Most (not all)
databases support transactions which are designed specifically with these sorts of scenarios in mind.

@cindex TransactionManager
ORMLite has basic support for transactions through the use of the @code{TransactionManager} class which wraps
databases operations in a transaction.  If those operations throw an exception, then the transaction is "rolled-back"
and none of the operations are persisted to the database.  Once the operations are finished, if no exception is thrown,
then the transaction is "committed" and the changes are written to the database.

@example
// we need the final to see it within the Callable
final Order order = new Order();

TransactionManager.callInTransaction(connectionSource,
  new Callable<Void>() @{
    public Void call() throws Exception @{
        // insert our order
        orderDao.create(order);
        // now add the order to the account
        account.setOrder(order);
        // update our account object
        accountDao.update(account);
        // you could pass back an object here
        return null;
    @}
@});
@end example

If for some reason, the @code{accountDao.update()} fails in the above example, the order insert will not be committed to
the database.  Transactions allow you to make multiple operations while still ensuring data integrity.  Notice that you
can return an object from the callable so you could pass back the number of rows affected or other information.

@emph{NOTE:} Performing database operations within a transaction also has the side effect of better performance since
a number of changes are written at once in a batch.  The @code{Dao.callBatchTasks()} method should always be used if
you are looking for performance of a large number of operations. @xref{callBatchTasks}.

@c ----------------------------------------------------------------
@node Object Caches, Maven, Transactions, Advanced
@section Object Caches

@cindex caching objects
@cindex object cache
@cindex level 1 cache
@cindex weak reference cache

ORMLite supports the ability to enable a basic object cache for a DAO.  The object cache keeps an internal collection of
objects that have been created or queried and will return a reference to the same object if it is handled in the future.  

For example:

@example
Dao<Account, String> accountDao =
    DaoManager.createDao(connectionSource, Account.class);
// enable the default object cache for this dao
accountDao.setObjectCache(true);

Account account = new Account("Jim Coakley");
accountDao.create(account);
// this will create the account object and add it to cache

Account result = dao.queryForId("Jim Coakley");
// this result will be the same object as account above
assertSame(account, result);
@end example

@emph{NOTE:} For an object cache to work, the class being stored must have an ID field.  If you try to enable the object cache for
a class without an ID field, an exception will be thrown.  The following operations are supported by the object cache:

@itemize @bullet

@item If you create an object using the DAO, it will be added to the cache.

@item When you query for an object using the standard query methods from the DAO, if the object is in the cache it will be returned.  If
it is not in the cache then it will be added to the cache.  This does @emph{not} apply to the @code{queryRaw(...)} methods.

@item If you update an object with the database using the DAO, if it exists in the cache it will be updated as well. 

@item If you refresh an object from the database using the DAO, if it exists in the cache it will be refreshed as well. 

@item If you delete the object using the DAO, the object will be deleted from the cache.  All delete methods are supported.

@end itemize

@cindex soft reference cache
@cindex ReferenceObjectCache
By default the cache that is used internally by ORMLite if you enable the cache with @code{true} will be a "weak-reference" cache.  This
means that if no other code has a strong reference to the object, it will be removed from the cache during the next garbage collection
cycle. ORMLite also has a "soft-reference" cache which will use more memory to hold objects if available and supported by your OS.  You
can enable it using:

@example
Dao<Account, String> accountDao =
    DaoManager.createDao(connectionSource, Account.class);
// enable a soft-reference cache
accountDao.setObjectCache(
    ReferenceObjectCache.makeSoftCache());
@end example

The reference caches store a small object that refers to the cached object.  These small objects only get cleaned up when the object is
accessed.  You should consider calling the @code{cleanNullReferencesAll()} method on your cache to remove these objects and free up
their associated memory on occasion.

@cindex LRU cache
@cindex LruObjectCache
There is also a Least Recently Used (LRU) cache that will store a certain number of objects based on a capacity value.  Each class gets
the same capacity value so if the same cache is used in 5 different daos, then 500 objects will be held in the @code{LruObjectCache} if
the capacity is 100.

@example
Dao<Account, String> accountDao =
  DaoManager.createDao(connectionSource, Account.class);
// enable least-recently-used cache with max 100 items per class
accountDao.setObjectCache(new LruObjectCache(100));
@end example

You can also implement your own cache class that implements the @code{ObjectCache} interface.

All of the caches can be cleared if you want to free up memory and you can also disable the cache from the DAO if necessary.

@example
// clear all Account items from the cache
accountDao.clearObjectCache();
@dots{}
// disable the cache
accountDao.setObjectCache(false);
@end example

@c ----------------------------------------------------------------
@node Maven, Batch Operations, Object Caches, Advanced
@section Configuring a Maven Project

@cindex maven configuration

To use ORMLite in your project if you are using maven, then you should add the following configuration stanza
to your @code{pom.xml} file.  As mentioned below, you will also need to add some database driver as well to your
dependency list.  In this example we are using MySQL but any of the supported JDBC database drivers will do.

@example
<project>
    @dots{}
    <dependencies>
        <!-- this has a dependency on ormlite-core -->
        <dependency>
            <groupId>com.j256.ormlite</groupId>
            <artifactId>ormlite-jdbc</artifactId>
            <version>@value{ormlite_version}</version>
        </dependency>
        <!-- You will need to add some sort of database driver too.
             In this example we've used MySQL. -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.10</version>
        </dependency>
    </dependencies>
</project>
@end example

The @code{-jdbc} artifact mentioned in the example depends on the @code{-core} artifact, but that should be pulled
in automatically by maven.

@emph{NOTE:} I do not have any details about how to configure Android projects with maven.  If you are doing so
then just replace the @code{ormlite-jdbc} artifact name with @code{ormlite-android}.

@c ----------------------------------------------------------------
@node Batch Operations, Custom Persisters, Maven, Advanced
@section Running Batch Operations

@cindex batch operations
@cindex bulk inserts
@cindex callBatchTasks
Every so often you need to efficiently do a number of database updates at one time -- bulk database inserts is a common
pattern.  ORMLite supports a @code{callBatchTasks} method on the @code{Dao} class which supports this behavior in most
database types.  For example:

@example
final List<Account> accountsToInsert = new ArrayList<Account>();
@dots{}
accountDao.callBatchTasks(new Callable<Void>() @{
    public Void call() throws Exception @{
        for (Account account : accountsToInsert) @{
            accountDao.create(account);
        @}
    @}
@});
@end example

Databases by default commit changes after every SQL operation.  This method disables this "auto-commit" bahavior so a
number of changes can be made faster and then committed all at once.  More specifically, the method turns "auto-commit",
calls the @code{Callable.call()} method passed in as an argument, calls SQL @code{commit} to persist the changes when the
call returns, and finally re-enabled auto-commit.  Some databases do not support auto-commit so a transaction may be used
to accomplish the same behavior.

@emph{NOTE:} If neither auto-commit nor transactions are supported by the database type then @code{callBatchTasks} method
may do nothing.

@c ----------------------------------------------------------------
@node Custom Persisters, How to Upgrade, Batch Operations, Advanced
@section Custom Data Type Persisters

@anchor{custom data persister}
@cindex custom persisters
@cindex custom data types
@cindex storing custom data types
@cindex overriding how data is stored

ORMLite has internal definitions for storing the basic primitive and other common data types. @xref{Persisted Types}.
Sometimes, however, you either want to store a new data type in your database or you want to change the way ORMLite
stores values to the database for common types -- this often happens when you are trying to work with an existing schema.
You can change how types are stored in the database by defining a class which implements the @code{DataPersister} interface.

For example, you might have a @code{Date} field in an existing database that was not nullable but instead stored the date
@code{0000-00-00} when there was no date.  You want ORMLite to return null if the 0 date was retrieved from the database.
To implement a custom data persister to handle the @code{Date} type in this manner would probably override the
@code{com.j256.ormlite.field.types.DateType} class and tweak the result-to-sql-argument method as follows:

@example
@@Override
public Object resultToSqlArg(FieldType fieldType,
      DatabaseResults results, int columnPos)
      throws SQLException @{
   Timestamp timestamp = results.getTimestamp(columnPos);
   if (TODO: somehow test fo 0000-00-00 here)
      return null;
   else
      return timestamp;
@}
@end example

The data persister example has a @code{MyDatePersister} class which does just that.  @xref{data persister example}.
To use your persister class on a particular field in your objects, you would do something like this:

@example
@@DatabaseField(persisterClass = MyDatePersister.class)
Date birthDate;
@end example

ORMLite also allows you to define data persisters for atypical or custom data types that are not handled at all by
the internal classes.  When defining a data persister class from scratch, you could extend one of the other data type
persisters or the @code{BaseDataType} class.  You will need to define the following methods.

@enumerate
@item @code{parseDefaultString} -- Converts a default string into a SQL argument suitable to be loaded into the database. 
@item @code{resultToSqlArg} -- Uses the @code{DatabaseResults} object to get the right SQL argument type out of the
results.
@item @code{sqlArgToJava} -- Converts the SQL argument to the associated Java class. 
@end enumerate

Look at the other data
types in @code{com.j256.ormlite.field.types} for other examples.  When you have defined your persister class, you can use
it with the @code{persisterClass} construct above or you can register it with the
@code{DataPersisterManager.registerPersisters(...)} method.  This will then automatically call your persister whenever a
field with the associated class is configured.
  
@example
DataPersisterManager.registerDataPersisters(
   MyTypePersister.getSingleton());
@end example

You probably would not want to register the @code{MyDatePersister} above because you would not want to change the 
persistence behavior for @emph{all} @code{Date} types.

@c ----------------------------------------------------------------
@node How to Upgrade, 5.2, Custom Persisters, Top
@chapter Upgrade From Old Versions

@cindex upgrading from previous versions
@cindex versions, upgrading
@cindex changes with ORMLite versions
@cindex how to upgrade
We strive to maintain backwards compatibility and to provide deprecated versions of old classes and methods.
However, sometimes when a new version is released, changes are made that require programmers to change their code
and rarely the on-disk database formats. 

@menu
* 5.2::                 Notes about version 5.2
* 5.1::                 Notes about version 5.1
* 5.0::                 Notes about version 5.0
* 4.49::                Notes about version 4.49
* 4.45::                Upgrade to version 4.45
* 4.43::                Problems with version 4.43
* 4.37::                Upgrade to version 4.37
* 4.30::                Upgrade to version 4.30
* 4.20::                Upgrade to version 4.20
* 4.14::                Upgrade to version 4.14
* 4.10::                Upgrade to version 4.10
* 4.0::                 Upgrade to version 4.0
* 3.2::                 Upgrade to version 3.2
* 2.4::                 Upgrade to version 2.4
@end menu

@c ----------------------------------------------------------------
@node 5.2, 5.1, How to Upgrade, How to Upgrade
@section Notes About Version 5.2

In version 5.2, we fixed issues with the boolean SQL types.  The boolean number type now correctly uses the
@code{BOOLEAN} SQL type instead of @code{BYTE}.  The  boolean character type now correctly uses the @code{CHAR} SQL
type instead of @code{STRING}.  Although we don't anticipate any issues with this, the developers thought it prudent
to mention it in case it causes compatibility issues.  

We also did refactoring in the @code{ormlite-jdbc} jar by renaming a number of types so it could be fulling Java9 
compliant.  Before there were overlapping packages.  Now all code in the @code{ormlite-jdbc} is under the 
@code{com.j256.ormlite.jdbc} package.   You may need to edit your imports if you were refering to any of these
classes.

@c ----------------------------------------------------------------
@node 5.1, 5.0, 5.2, How to Upgrade
@section Notes About Version 5.1

In version 5.0, we moved to using English for the field and method name capitalization because of problems with how
certain languages capitalize certain characters.  Some of the capitalization points were missed however and this
version fixes a couple of additional spots where field and method capitalization was still using the default locale.

If you want ORMLite to use the old way to keep compatibility, you should generate your connection source with a custom
database type that uses your default locale by overriding the following methods:

@itemize @bullet
@item @code{upCaseEntityName(String)}
@item @code{upCaseString(String, boolean)}
@item @code{downCaseString(String, boolean)}
@end itemize

These methods should just return @code{string.toUpper()} or @code{string.toLower()} which will use your default
locale.  You can also specify a specific locale if necessary.

@c ----------------------------------------------------------------
@node 5.0, 4.49, 5.1, How to Upgrade
@section Notes About Version 5.0

A number of things have changed and it's been a long time since the last published ORMLite release, so a .0 number
on the release seemed to be warranted.  See the following details.

@itemize @bullet

@item ORMLite now requires Java 6 and no longer supports Java 5.

@item We used the native locale to do uppercase database entity names (tables and fields).  This
sounds like a good idea until you realize that in Turkish, a uppercase i with a dot is a capital I with a dot which can
be incompatible with databases that don't understand UTF8 names.  For this reason the default behavior is to do
capitalization of entities using @code{Locale.ENGLISH}.  This means that your schema may need to change.  To go back
to the old behavior, you should override the appropriate @code{DatabaseType} and override the
@code{upCaseEntityName(String)} method.

@item We've added the usage of the @code{java.io.Closeable} interface in a number of places for Java 7 support. This means
that you may not get warnings about unclosed iterators and other things.  Watch for and pay attention to them.  They are
important.  Java 7 is not required.

@item To better support database partitioning, we made some changes to the @code{ConnectionSource} interface so now the
table name is specified which allows the @code{ConnectionSource} to make decisions about which database to connect to
depending on the table.

@item We've made changes to Android to better support the @code{java.sql.Timestamp} and @code{java.sql.Date} as strings
in the database.  If you were using this types before you may have to add a @code{persisterClass = TimeStampType.class}
or  @code{SqlDateType.class}.

@item We've removed a number of deprecated methods:

@itemize
@item Dao.setAutoCommit(boolean), isAutoCommit()
@item QueryBuilder.clear(), limit(int), offset(int) 
@item ForeignCollectionField.maxEagerForeignCollectionLevel(), foreignColumnName()
@item DatabaseFieldConfig.setMaxEagerForeignCollectionLevel(), setForeignCollectionMaxEagerForeignCollectionLevel(),
setForeignCollectionOrderColumn(), setForeignCollectionForeignColumnName()
@item DataSourceConnectionSource.setUsesTransactions(boolean)
@item JdbcPooledConnectionSource.setUsesTransactions(boolean)
@item OpenHelperManager.release()
@item AndroidDatabaseResults(Cursor, boolean, ObjectCache) constructor
@end itemize

@end itemize

@c ----------------------------------------------------------------
@node 4.49, 4.45, 5.0, How to Upgrade
@section Notes About Version 4.49

The 4.49 release took a long time to put out unfortunately so it included a lot of changes, a couple of which need
to be specifically enumerated.  For more details, please check the change-log.

@itemize @bullet

@item Due to a couple of reporting issues, it was determined that some sort of locking was needed to protect concurrent
usage of @code{dao.callBatchTasks(...)} calls from multiple threads when dealing with a single database connection.  ORMLite
now makes an attempt to detect a single-connection connection-source and will enforce locking so that only one batch
task can be running at a time.

@item A lot of changes were made to have @code{CloseableIterator} and other classes extend @code{java.io.Closeable}.  If
you are extending any of these classes then you may have to tweak your code.

@item We fixed a problem with the @code{maxForeignAutoRefreshLevel} configuration setting which was particularly impacting
Android users.

@end itemize

Again, please check the change-log for the entire list.

@c ----------------------------------------------------------------
@node 4.45, 4.43, 4.49, How to Upgrade
@section Upgrade to Version 4.45

To fix the date-string format bug introduced in version 4.43, I've decided to revert back to the date-string of
@code{yyyy-MM-dd HH:mm:ss.SSSSSS} from the one introduced in 4.43 which was @code{yyyy-MM-dd HH:mm:ss.SSS}.  This means
that for folks doing date comparisons or using the @code{version = true} feature, if you have created data under 4.43
you will have to add the following to your date fields to make it work.

@example
@@DatabaseField(version = true, format="yyyy-MM-dd HH:mm:ss.SSS",
   dataType=DataType.DATE_STRING)
private Date date;
@end example

If you have data that was created @emph{both} in 4.42 or before and 4.43 or 4.44 then you will have to convert some of
the data.  Something like the following @code{UPDATE} statement should work:

@example
UPDATE your-table SET your-date-field =
    CONCAT(SUBSTRING(your-date-field, 1, 20), "000",
       SUBSTRING(your-date-field, 20, 3))
    WHERE LENGTH(your-date-field) = 23;
@end example

My sincere apologies for this mess up.

@c ----------------------------------------------------------------
@node 4.43, 4.37, 4.45, How to Upgrade
@section Problems With Version 4.43

In the process of looking into adding the timezone to the date-string, I made a change to the date-string format from
@code{yyyy-MM-dd HH:mm:ss.SSSSSS} to @code{yyyy-MM-dd HH:mm:ss.SSS} -- changing the milliseconds output from 6 digits to 3.
This relatively small change @emph{broke} the equality checking for date-strings which meant that @code{Where.eq(...)} and
@code{version = true} field settings ceased to work correctly.  The version processing code uses equality to verify that
the object date is the same with the database and the new string value @code{...###} is not equal to the old database
format of @code{...######}.

We have fixed this problem in 4.45 which reverts the string format.  If you want to fix it permanently, you can use the
@code{format} specifier on your date-string fields:

@example
@@DatabaseField(version = true, format="yyyy-MM-dd HH:mm:ss.SSSSSS",
   dataType=DataType.DATE_STRING)
private Date date;
@end example

My apologies for this problem.

@c ----------------------------------------------------------------
@node 4.37, 4.30, 4.43, How to Upgrade
@section Upgrade to Version 4.37

@cindex Android case sensitive columns
@cindex case sensitive columns, Android
For Android users, in 4.37 we fixed a problem with the looking up of column names with imbedded periods in them by implementing
our own lookup and not using the Android API.  This had the unintended consequence of making the field name lookups be case
@emph{sensitive}.  If you used ORMLite to generate your tables or if you used the @code{@@DatabaseField} @code{columnName}
to match the case then you would @emph{not} be affected by this issue.  But if you were working with an existing database with
field names that did @emph{not} match the case of the Java fields, then as of 4.37 you would be seeing the following exception.  

@example
java.sql.SQLException: Unknown field 'accountName' from the
    Android sqlite cursor, not in:[accountname, ...]"
@end example

Since other parts of the system are @emph{also} case sensitive, we made the decision to not fix this problem but to encourage
our users to properly use the @code{@@DatabaseField} @code{columnName} if the case of your database does not match your
Java fields.  @xref{columnName}.

For example, before 4.37 your Android SQLite database might have the column @code{accountname} although your Java field might
actually be @code{accountName}.  As of 4.37, when you look up your Java fields you will have to add a @code{columnName} value
like the following:

@example
@@DatabaseField(columnName = "accountname")
private String accountName;
@end example

We made the decision to force this change because there are other parts of ORMLite that are @emph{already} case sensitive. 
For example, if you had mismatched case in your field names then using the @code{dao.queryForMatching(obj)} method would
not work without the case matching the database.   If you were building a custom query, you would have to say
@code{queryBuilder.where().eq("columnname", value)} and could not use @code{columnName}.

Sorry for not recognizing this incompatibility earlier.

@c ----------------------------------------------------------------
@node 4.30, 4.20, 4.37, How to Upgrade
@section Upgrade to Version 4.30

For Android users, in 4.30 we added some reflection hacks to make the processing of the @code{@@DatabaseField} annotations
a lot faster.  For this reason the following changes must be made:

@itemize @bullet

@item Instead of calling the annotation methods directly which causes tons of unnecessary GC objects, we use reflection and
build a @code{DatabaseTableConfig} instead.  This means that if you have defined custom Dao classes, you will need to add
a new constructor:

@example
public class AccountDaoImpl extends BaseDaoImpl<Account, String>
  implements AccountDao @{
    public AccountDaoImpl(ConnectionSource connectionSource)
      throws SQLException @{
        super(connectionSource, Account.class);
    @}
    // NOTE: this constructor is needed under Android in 4.30
    public AccountDaoImpl(ConnectionSource connectionSource,
        DatabaseTableConfig<Account> tableConfig)
      throws SQLException @{
        super(connectionSource, tableConfig);
    @}
@}
@end example

@item Because we had to write specific code to reflect on the @code{@@DatabaseField} annotation we have deprecated the
@code{@@DatabaseFieldSimple} and other annotations that were added in version 4.26.  Sorry for the reversal on this but
they were also causing confusion.

@end itemize

@c ----------------------------------------------------------------
@node 4.20, 4.14, 4.30, How to Upgrade
@section Upgrade to Version 4.20

In 4.20 we made a couple of changes that bear some note.

@itemize @bullet

@item For Android developers, we significantly improved the mechanism for injecting the class of the database open helper.
Setting the class name in the @code{strings.xml} resource file is still supported although it is not necessary if you are using
@code{OrmLiteBaseActivity} or the other base classes.  If you are extending those classes, ORMLite will detect the helper
class automagically.  The @code{SqliteOpenHelperFactory} mechanism, although still supported, has been deprecated.
@xref{database open helper wiring}.  

@item We added the @code{uniqueCombo} setting for uniqueness across field combinations.  We also changed the SQL that was generated
if you are using the @code{unique} setting.  The old SQL was correct but the new versions are more compatible with the SQL standard
and the various database types.  @xref{unique constraints}.

@item We did some memory audits of ORMLite and improved the way that we were using DAOs internally so that we use cached DAOs where
possible.  We also improved the memory usage with foreign fields and some of the @code{TableUtil} methods.  Thanks much to various
folks on the user list who significantly helped with this process.

@end itemize

@c ----------------------------------------------------------------
@node 4.14, 4.10, 4.20, How to Upgrade
@section Upgrade to Version 4.14

In 4.14 we added a @code{DatabaseType.BYTE_ARRAY} which stores @code{byte[]} directly.  @xref{BYTE_ARRAY}.  In the past, this array
would have been stored as a serialized array of bytes.  To not break backwards compatibility with the database, fields with the
@code{byte[]} type @emph{must} now specify either the @code{BYTE_ARRAY} or @code{SERIALIZABLE} types using the @code{dataType} field
on @code{@@DatabaseField} -- it will not be chosen automatically.  @xref{DatabaseField dataType}.  If we did not do this then
previously stored data would be read from the database improperly.

In addition, serialized types must also now specify their @code{dataType} value.  You should use @code{DataType.SERIALIZABLE} to
continue to store serialized objects in the database.  This will allow us to add direct support for other serialized types in the
future without breaking backwards compatibility.

If you already have Serializable data (byte[] or other objects) stored in a database then you will need to add something like the
following to your fields:

@example
@@DatabaseField(dataType = DataType.SERIALIZABLE)
Serializable field;
@end example

For newly stored byte[] fields, you could use the BYTE_ARRAY type to store the bytes directly.  But any existing data will @emph{not}
be converted automatically.

@example
@@DatabaseField(dataType = DataType.BYTE_ARRAY)
byte[] field;
@end example

@c ----------------------------------------------------------------
@node 4.10, 4.0, 4.14, How to Upgrade
@section Upgrade to Version 4.10

4.10 was a reasonably large release containing some feature upgrades and some bug fixes.  No data formats were changed, however
the following API code was altered:

@itemize @bullet

@item We significantly refactored the @code{RawResults} class which is now deprecated and replaced it with the
@code{GenericRawResults} class.  See the @code{GenericRawResults} for more information.  @xref{Raw Queries}.  

@item The @code{Dao} methods @code{queryForAllRaw()} and @code{iteratorRaw()} are now deprecated.  They are replaced with
@code{queryRaw(...)} methods.  See the @code{Dao} class javadocs for more information. 

@item Before this release the -jdbc and -android versions of ORMLite contained the -core functionality.  In this release we split
out the -core from the other packages so you will now need to install @emph{both} the core and android (or jdbc) packages to get the
package to work.

@end itemize

@c ----------------------------------------------------------------
@node 4.0, 3.2, 4.10, How to Upgrade
@section Upgrade to Version 4.0

No data formats were changed, however the following API code was altered.  Removed any outside usage of the @code{DatabaseType} since
the @code{ConnectionSource} now provides it.  Also added features to be able to prepare update and delete statements.  To provide
type safety, we've moved back to using @code{QueryBuilder} so we can have @code{UpdateBuilder} and @code{DeleteBuilder}.  And instead
of a @code{PreparedStmt} there is @code{PreparedQuery}, @code{PreparedUpdate}, and @code{PreparedDelete}.  Here are the details:

@itemize @bullet

@item We have removed most of the cases where the user has to deal with the @code{DatabaseType}.
All you need to set on the DAOs is the @code{ConnectionSource} which provides the database type 
internally.  To create and drop the tables, also, you only need the @code{ConnectionSource}.

@item Constructing a @code{BaseDaoImpl} now self-initializes if it is constructed with a
@code{ConnectionSource}.  This validates the class configurations meaning that it now throws a
@code{SQLException}.

@item Constructing a @code{JdbcConnectionSource} or @code{DataSourceConnectionSource} also now
throws a @code{SQLException} since they also now self-initialize if they are constructed with the URL.
This creates the internal database type and loads the driver class for it.  

@item Deprecated the @code{createJdbcConnectionSource} method in the @code{DatabaseTypeUtils} and
turned the @code{loadDriver} method into a no-op.  You now just instantiate the @code{JdbcConnectionSource}
directly and there is no need for referencing the @code{DatabaseTypeUtils} anymore.

@item @code{Dao.statementBuilder()} method changed (back) to @code{Dao.queryBuilder()}.

@item @code{Dao.queryBuilder()} returns a @code{QueryBuilder} instead of a @code{StatementBuilder}.

@item You now call @code{distinct()}, @code{limit()} and @code{offset()} on the @code{QueryBuilder}.
Unfortunately, there are no deprecated methods for them on the @code{StatementBuilder}.

@item You now call @code{selectColumns()} on the @code{QueryBuilder} instead of @code{columns()}
since now we have columns also in the @code{UpdateBuilder}.  Unfortunately, there are no deprecated
methods for them on the @code{StatementBuilder}.

@item You call @code{QueryBuilder.prepare()} instead of @code{StatementBuilder.prepareStatement()}.
It returns a @code{PreparedQuery} instead of a @code{PreparedStmt}.  You pass a @code{PreparedQuery}
into the @code{Dao.query()} and @code{Dao.iterator()} methods instead of a @code{PreparedStmt}.

@item We removed the @code{DatabaseTypeFactory} class since it was no longer needed for Spring
configurations.

@item Removed @code{BaseJdbcDao} since it had been deprecated in 3.X.

@end itemize

@c ----------------------------------------------------------------
@node 3.2, 2.4, 4.0, How to Upgrade
@section Upgrade to Version 3.2

The 3.2 release involved a @emph{very} large code reorganization and migration.  There were no on-disk changes unless you somehow
managed to get ORMLite working previously on Android.  The project was basically split into 3 pieces: core functionality, JDBC
database handlers, and the new Android handler.  With significant help from Kevin G, we abstracted all of the database calls into
3 interfaces: @code{ConnectionSource} (like a @code{DataSource}), @code{DatabaseConnection} (like a @code{Connection}) and
@code{DatabaseResults} (like a @code{ResultSet}).  Once we had the interfaces in place, we wrote delegation classes for JDBC and
Android handlers.  This means that as of 3.X we release 3 packages: ormlite-core (for developers), ormlite-jdbc (for people
connecting to JDBC databases), and ormlite-android (for Android users).  Both the JDBC and Android packages include all of the
core code as well.

Along the way a number of specific changes were made to the methods and classes:

@itemize @bullet

@item Since we split off the JDBC, we renamed the @code{BaseJdbcDao} to be @code{BaseDaoImpl} in the core package. You will
need to adjust any DAOs that you have.

@item We are in the process of allowing custom delete and update methods so we took the major upgrade opportunity to
rename the @code{QueryBuilder} object to be @code{StatementBuilder}.  @emph{NOTE:} this was reverted later.

@item Because of the above, we also renamed @code{Dao.queryBuilder()} method to be @code{statementBuilder()}.  @emph{NOTE:} this
was reverted later.

@item Also renamed the @code{PreparedQuery} object to be @code{PreparedStmt}.

@item One of the big changes for those of you using an external JDBC @code{DataSource} is that you no longer set it on the
DAO directly.  You need to wrap your @code{DataSource} in a @code{DataSourceConnectionSource} wrapper class which gets
set on the DAO instead.

@end itemize

Again, there were no on-disk changes unless you somehow managed to get ORMLite working previously on Android.  Since we were using
JDBC before to do the data marshaling and now are doing it by hand, some of the data representations may have changed.  Sorry for
the lack of detail here.

@c ----------------------------------------------------------------
@node 2.4, Examples, 3.2, How to Upgrade
@section Upgrade to Version 2.4

A bug was fixed in 2.4 with how we were handling Derby and Hsqldb.  Both of these databases seem to be capitalizing table and field
names in certain situations which meant that customized queries of ORMLite generated tables were affected.  In version 2.4,
all tables and field names are capitalized in the SQL generated for Derby and Hsqldb databases. This means that if you have data
in these databases from a pre 2.4 version, the 2.4 version will not be able to find the tables and fields without renaming to be
uppercase.

@c ----------------------------------------------------------------
@node Examples, JDBC Examples, 2.4, Top
@chapter Example Code

@cindex examples of code
@cindex code examples
Here is some example code to help you get going with ORMLite.  I often find that code is the best documentation of how
to get something working.  Please feel free to suggest additional example packages for inclusion here.  Source code submissions
are welcome as long as you don't get piqued if we don't chose your's.

@menu
* JDBC Examples::           Example code using JDBC calls. 
* Android Examples::        Example code for the Android OS.
@end menu

@c ----------------------------------------------------------------
@node JDBC Examples, Android Examples, Examples, Examples
@section JDBC Examples

@cindex JDBC examples
@cindex H2 examples
All of the JDBC examples below depend on the H2 database which is a native Java SQL implementation.  You can 
@uref{http://www.h2database.com/html/download.html, download the latest jar} from the website.

@table @asis

@cindex simple example
@item Simple, basic

This is a simple application which performs database operations on a single class/table.  See the
@uref{http://ormlite.com/docs/example-simple, source code}.

@cindex foreign objects example
@anchor{foreign objects example}
@item Foreign objects 

This example shows how to use foreign objects.  @xref{Foreign Objects}.  See the 
@uref{http://ormlite.com/docs/example-foreign, source code}.

@cindex foreign collections example
@anchor{foreign collections example}
@item Foreign collections 

This example shows how to use foreign collections.  @xref{Foreign Collection}.  See the
@uref{http://ormlite.com/docs/example-foreign-collection, source code}.

@cindex field configuration example
@anchor{field config example}
@item Field configuration 

This example shows how you can configure a class in ORMLite using Java code @emph{instead} of annotations.
@xref{Class Configuration}.  See the @uref{http://ormlite.com/docs/example-config, source code}.

@cindex many to many example
@anchor{many to many example}
@item Many to many 

This example is a bit more complicated with multiple tables and is designed for folks trying to model a many-to-many relationship.
It has a join-table, foreign fields, and also utilizes inner queries.   See the @uref{http://ormlite.com/docs/example-many,
source code}.

@cindex spring example
@anchor{spring example}
@item Spring wiring

To demonstrate how to use Spring wiring with ORMLite, this little program includes classes and XML configuration files.
See the @uref{http://ormlite.com/docs/example-spring, source code}.

@cindex data persister example
@cindex custom data persister example
@anchor{data persister example}
@item Data persister

This example shows how to define custom data persisters with ORMLite which can change how data types are stored in the
database.  See the @uref{http://ormlite.com/docs/example-data-persister, source code}.

@end table

@c ----------------------------------------------------------------
@node Android Examples, Contributions, JDBC Examples, Examples
@section Android Examples

@cindex Android examples
For Android developers, here some complete example application projects to help you get started.  See here for
@uref{http://ormlite.com/android/examples/, tarballs of all of the packages} as well as code links.

@table @asis

@item HelloAndroid

A basic Android application which does some database operations and then quits.

@item ClickCounter

A nice little application written by Kevin G. that provides a counter type application using ORMLite.

@item NotifyService

An example of a service application that uses ORMLite written by Kevin G.

@item HelloAndroidH2

This is similar to the HelloAndroid example but it is using JDBC and H2 instead of the build-in Android database calls.  This is more
a proof of concept rather than a true example.  The wiring for the @code{onCreate} and @code{onUpdate} is a hack.   H2 is certainly
larger, has tons more features, but is slower than the native SQLite.  Also, JDBC under Android is @emph{not} completely sanctioned by
Google and support for it may be removed in the future.

@item HelloAndroidNoBase

This is similar to the HelloAndroid example but its activity does not extend the @code{OrmLiteBaseActivity} but instead manages the
helpers itself.  Certain programmers may want to manage the database connections using their own code to better share between
activities and services or to use ORMLite when it is not possible to extend the base classes.

@item HelloAndroidTwoDbs

This is similar to the HelloAndroid example but it uses two separate databases, manages the helpers itself, and does not
use the @code{OpenHelperManager} to manage the helpers at all.  This is one way that you can deal with two different databases.

@end table

@c ----------------------------------------------------------------
@node Contributions, License, Android Examples, Top
@chapter Contributions

@cindex contributors
There are a number of people who have helped with this project.  If I've forgotten you @emph{please} remind me so I can add you to
this list.  Let me know if you'd like to tune your name or add link to your home page here as well.

Thanks much to them all.

@itemize @bullet

@item Kevin Galligan was the impetus and the author of a good bit of the Android compatible code.  He wrote the Android level support
classes and did a ton of beta-testing of it.  He's also provided the initial Android examples.  See @uref{http://www.kagii.com/}.

@item JC Romanda has been an excellent addition to the user base providing feedback, discovering and reporting bugs, providing patches
for new features, testing new features before the release, and thinking a lot about how ORMLite can be extended and improved.

@item Nelson Erb was our self-appointed documentation and testing volunteer for a year.  He did a great job summarizing sections of
this document so we could create a better 'Getting Started' section.  He also fleshed out a bunch of unit tests to improve coverage.

@item Craig Andrews and Pedro Velasco has been very quick with feedback, bug reports, feature requests and other help.

@item Jim Gloor was one of the Java gurus at a previous company.  His great object instincts and the JDBC code samples helped start this
project.

@item Robert Adamsky was a colleague of mine at a company where he laid out our entire DAO and hibernate class hierarchy.  The
@code{DAO} interface and the @code{BaseDaoImpl} where in some part modeled after his code.

@c -----------------
@c Extracted from the ChangeLog up through version 4.49

@item Thanks much to the following folks for their bug reports, unit test submissions, memory analysis, code samples, feature
requests, improvements, and general feedback:
51mon,
Adam Brown,
AlexPal,
Ali Aksakarya,
Andre,
Andrea Sprega,
Andreas,
Andrew Sleeman,
Andrew8er,
Andrey,
Anthony Whitlock,
Bart,
Ben Mosher,
Candlejack,
Carlos Fonseca,
Casey,
Chad Schultz,
Chase,
Chris Banes,
Chris Nevill,
Christian Ruppert,
Dale Asberry,
Daniel Colchete,
Daniel Jette,
Diederik,
Eric Fung,
Evan Grim,
Farrukh Najmi,
Filipe Leandro,
Flo,
Guillermo Campelo,
HeDYn,
Howard Liberty,
Ian Dees,
Javier Hinmel,
Jaxelrod,
Jaykob,
Jean-Maxime Pelletier,
Jeremy Mcjunkin,
Jeremy Stone,
Jeroen Rakhorst,
Joao Bosco,
John Kristian,
Johny Jugianto,
Jomble,
Jonathan Caryl,
Joseph Jones,
Josh Guilfoyle,
Kaan,
Kyle Lampert,
Larry Hamel,
Lder,
Livelazily,
Lstrzelecki,
Luke Meyer,
ManosProm,
Mariak Kalman,
Mark Rogers,
Markus Wiederkehr,
Mathias Lin,
Micael Dahlgren,
Michael,
Michael Weimann,
Ming Lin,
Miroslav Nadhajsky,
Mohammad Moghimi,
Nathan Jones,
Natinusala,
Nick Campion,
Nonameplum,
Outofrange,
Patras Vlad,
Pavel Arnost,
Patrick,
Pedro Velasco,
Rahan,
Ramps,
Richard Kooijman,
Roger Keays,
Roland Oldenburg,
Roman Zimmer,
Sebastian Roth,
Skylar,
Slava Tysianchuk,
Spacetime,
Stephen Couchman,
Stew,
Stewert,
Timo,
Tom Tantisalidchai,
Tony,
Tonyxiao,
Tsharp,
VincentFTS,
Vladimir,
Wayne Stidolph,
Wener,
Yossi Wasserman,
Birbird,
Coder sam,
Glenviewjeff,
Igromanru,
Jon,
Mjomble,
Nybblr,
Shikajiro,
Steffen,
Zachawilson
.

@end itemize

Thanks much to them all.

@c ----------------------------------------------------------------
@node License, Index of Concepts, Contributions, Top
@chapter ISC Open Source License

@cindex license
@cindex isc license
@cindex open source license
This document is part of the ORMLite project.

Copyright @value{ormlite_year}, Gray Watson

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby
granted, provided that this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.

@c ----------------------------------------------------------------
@node Index of Concepts,, License, Top
@unnumbered Index of Concepts

@printindex cp

@ifhtml
@contents
@end ifhtml

@bye
